概述

都有哪些维度可以进行数据库调优?

1. 索引失效、没有充分利用到索引——索引建立。
2. 关联查询太多JOIN （设计缺陷或不得已的需求）——SQL优化。
3. 服务器调优及各个参数设置（缓冲、线程数等）——整my.cnf。
4. 数据过多――分库分表

---

SQL查询优化的技术有很多，但是大方向上完全可以分成**物理查询优化**和**逻辑查询优化**两大块。

1. 物理查询优化是通过**索引**和**表连接方式**等技术来进行优化，这里重点需要掌握索引的使用。
2. 逻辑查询优化就是通过SQL**等价变换**提升查询效率，直白一点就是说，换一种查询写法执行效率可能更高。

# 数据准备

**学员表**插 50万条， **班级表**插 1万条。

1. 建表

   ```mysql
   CREATE TABLE `class` (
   `id` INT(11) NOT NULL AUTO_INCREMENT,
   `className` VARCHAR(30) DEFAULT NULL,
   `address` VARCHAR(40) DEFAULT NULL,
   `monitor` INT NULL ,
   PRIMARY KEY (`id`)
   ) ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;
   ```

   ```mysql
   CREATE TABLE `student` (
   `id` INT(11) NOT NULL AUTO_INCREMENT,
   `stuno` INT NOT NULL ,
   `name` VARCHAR(20) DEFAULT NULL,
   `age` INT(3) DEFAULT NULL,
   `classId` INT(11) DEFAULT NULL,
   PRIMARY KEY (`id`)
   ) ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;
   ```

2. 允许创建函数设置

   ```mysql
   set global log_bin_trust_function_creators=1;
   ```
   
3. 创建函数

   ```mysql
   # 随机产生字符串
   DROP FUNCTION rand_string;
   DELIMITER //
   CREATE FUNCTION rand_string(n INT) RETURNS VARCHAR(255)
   BEGIN
   DECLARE chars_str VARCHAR(100) DEFAULT
   'abcdefghijklmnopqrstuvwxyzABCDEFJHIJKLMNOPQRSTUVWXYZ';
   DECLARE return_str VARCHAR(255) DEFAULT '';
   DECLARE i INT DEFAULT 0;
   WHILE i < n DO
   SET return_str =CONCAT(return_str,SUBSTRING(chars_str,FLOOR(1+RAND()*52),1));
   SET i = i + 1;
   END WHILE;
   RETURN return_str;
   END //
   DELIMITER ;
   ```

   ```mysql
   # 随机产生多少到多少的数字
   DROP FUNCTION rand_num;
   DELIMITER //
   CREATE FUNCTION rand_num (from_num INT ,to_num INT) RETURNS INT(11)
   BEGIN
   DECLARE i INT DEFAULT 0;
   SET i = FLOOR(from_num +RAND()*(to_num - from_num+1)) ;
   RETURN i;
   END //
   DELIMITER ;
   ```

4. 创建存储过程

   ```mysql
   # 往stu表中插入数据的存储过程
   DELIMITER //
   CREATE PROCEDURE insert_stu( START INT , max_num INT )
   BEGIN
   DECLARE i INT DEFAULT 0;
   SET autocommit = 0;
   REPEAT
   SET i = i + 1;
   INSERT INTO student (stuno, name ,age ,classId ) VALUES
   ((START+i),rand_string(6),rand_num(1,50),rand_num(1,1000));
   UNTIL i = max_num
   END REPEAT;
   COMMIT;
   END //
   DELIMITER ;
   ```

   ```mysql
   # 往class表中插入数据的存储过程
   DELIMITER //
   CREATE PROCEDURE `insert_class`( max_num INT )
   BEGIN
   DECLARE i INT DEFAULT 0;
   SET autocommit = 0;
   REPEAT
   SET i = i + 1;
   INSERT INTO class ( classname,address,monitor ) VALUES
   (rand_string(8),rand_string(10),rand_num(1,100000));
   UNTIL i = max_num
   END REPEAT;
   COMMIT;
   END //
   DELIMITER ;
   ```
   
5. 调用存储过程

   ```mysql
   # 往class表添加1万条数据
   CALL insert_class(10000);
   ```

   ```mysql
   # 往stu表添加50万条数据
   CALL insert_stu(100000,500000);
   ```

6. 删除指定表的索引

   ```mysql
   # 创建存储过程
   DELIMITER //
   CREATE PROCEDURE `proc_drop_index`(dbname VARCHAR(200),tablename VARCHAR(200))
   BEGIN
       DECLARE done INT DEFAULT 0;
       DECLARE ct INT DEFAULT 0;
       DECLARE _index VARCHAR(200) DEFAULT '';
       DECLARE _cur CURSOR FOR SELECT index_name FROM
       information_schema.STATISTICS WHERE table_schema=dbname AND table_name=tablename AND
       seq_in_index=1 AND index_name <>'PRIMARY' ;
       DECLARE CONTINUE HANDLER FOR NOT FOUND set done=2 ;
       OPEN _cur;
       FETCH _cur INTO _index;
       WHILE _index<>'' DO
           SET @str = CONCAT("drop index " , _index , " on " , tablename );
           PREPARE sql_str FROM @str ;
           EXECUTE sql_str;
           DEALLOCATE PREPARE sql_str;
           SET _index='';
           FETCH _cur INTO _index;
       END WHILE;
       CLOSE _cur;
   END //
   ```

   ```mysql
   # 调用存储过程
   CALL proc_drop_index("dbname","tablename");
   ```

# 索引失效案例

## 全值匹配

创建联合索引多个索引同时生效。

经常出现的sql语句如下：

```mysql
SELECT SQL_NO_CACHE * FROM student WHERE age=30;
SELECT SQL_NO_CACHE * FROM student WHERE age=30 and classId=4;
SELECT SQL_NO_CACHE * FROM student WHERE age=30 and classId=4 AND name = 'abcd';
```

建立索引**前**执行，关注执行时间：

```mysql
SELECT SQL_NO_CACHE * FROM student WHERE age=30 and classId=4 AND name = 'abcd';
```

![image-20230823170119440](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230823170119440.png)

建立索引

```mysql
CREATE INDEX idx_age ON student(age);

CREATE INDEX idx_age_classid ON student(age, classId);

CREATE INDEX idx_age_classid_name ON student(age, classId, name);
```

建立索引**后**执行，关注执行时间：

```mysql
SELECT SQL_NO_CACHE * FROM student WHERE age=30 and classId=4 AND name = 'abcd';
```

![image-20230823170352706](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230823170352706.png)

可以看到，建立索引后的查询效率有很明显的提升。

## 最佳左前缀法则

建立**联合索引**时会遵守**最佳左前缀**匹配原则，即最左优先，在查找数据时从联合索引的**最左边**开始匹配。

例如1：

```mysql
EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE student.age=30 AND student.name = 'abcd';
```

![image-20230823170954340](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230823170954340.png)

---

例如2：

```mysql
EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE student.classid=1 AND student.name = 'abcd';
```

![image-20230823171057703](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230823171057703.png)

> 没有使用上索引。

---

例如3：

提问：是否能使用上**idx_age_classid_name**索引？

```mysql
EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE classid=4 and student.age=30 AND student.name = 'abcd';
```

![image-20230823172111676](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230823172111676.png)

答案：是能够使用上idx_age_classid_name的，但SQL语句中并没有按照索引列的顺序进行过滤查询，为什么还能使用上索引呢？这是因为MySQL对SQL语句进行了重写。可以使用**SHOW WARNINGS**命令查看重写后的SQL语句。

```mysql
SHOW WARNINGS\G;
```

![image-20230823172710736](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230823172710736.png)

---

例如4：

```mysql
EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE student.age=30 AND student.name ='abcd';
```

![image-20230823173340771](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230823173340771.png)

> 此查询跳过了classId字段，导致后面的name字段也没用上索引，只有age字段用上了索引。

---

结论：

1. MySQ可以为**多个字段**创建索引，一个索引可以包括16个字段。
2. 使用多列索引时，**过滤条件要使用索引必须按照索引建立时的顺序，依次满足，一旦跳过某个字段，索引后面的字段都无法被使用**。
3. 如果查询条件中没有使用索引中的**第1个字段**时，多列（或联合）索引不会被使用。

## 主键插入顺序

对于一个使用**InnoDB**存储引擎的表来说，表中的数据实际上都是存储在**聚簇索引**的叶子节点。而记录又是存储在数据页中的，数据页和记录又是按照记录**主键值从小到大**的顺序进行排序，如果**插入**的记录的**主键值是依次增大**的话，那么每插满一个数据页就换到下一个数据页继续插，如果插入的主键值**忽大忽小**的话，就比较麻烦，假设某个数据页存储的记录已满，它存储的主键值在**1~100**之间：

![image-20220326225238412](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20220326225238412.png)

如果此时插入一条主键值为**9**的记录，那它插入的位置就如下图：

![image-20220326225248650](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20220326225248650.png)

可是这个数据页已满，再插进来咋办呢？需要**把当前页面分裂成两个页面**，把当前页中的一些记录移动到新创建的页中。页面分裂和记录移位会导致性能损耗，所以尽量避免这种无谓的性能损耗，最好让插入的记录的**主键值依次递增**。

## 函数导致索引失效

```mysql
# 给student表name列建立索引
CREATE INDEX idx_name ON student(name);
```

```mysql
# 方式1：使用LEFT函数
EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE LEFT(student.name, 3) = 'abc';
```

```mysql
# 方式二：使用SUBSTRING函数
EXPLAIN SELECT id,stuno,name FROM student WHERE SUBSTRING(name, 1, 3) = 'abc';
```

```mysql
# 方式三：使用模糊查询
EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE student.name LIKE 'abc%';
```

执行结果：

![image-20230823180317886](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230823180317886.png)

**结论：在SQL的WHERE语句中使用函数可能会导致索引失效。**

## 计算导致索引失效

```mysql
# 给student表stuno列建立索引
CREATE INDEX idx_sno ON student(stuno);
```

```mysql
EXPLAIN SELECT SQL_NO_CACHE id, stuno, NAME FROM student WHERE stuno + 1 = 900001;
```

![image-20230823181226710](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230823181226710.png)

**结论：在SQL的WHERE语句中进行计算操作可能会导致索引失效。**

## 类型转换导致索引失效

```mysql
EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE name = 123;
```

```mysql
EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE name = '123';
```

![image-20230823182120017](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230823182120017.png)

**结论：**`name = 123`发生类型转换导致索引失效。

## 范围条件导致右边的列索引失效

```mysql
# 删除student表中其他索引防止被干扰
ALTER TABLE student DROP INDEX idx_name;
ALTER TABLE student DROP INDEX idx_age;
ALTER TABLE student DROP INDEX idx_age_classid;
```

```mysql
EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE student.age = 30 AND student.classId > 20 AND student.name = 'abc';
```

![image-20230823182831468](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230823182831468.png)

**结论：**范围条件查询会导致右边的列索引失效，上面的例子中name列没有使用上索引。可以考虑在创建索引时将范围条件的列放在后面。

```mysql
CREATE INDEX idx_age_name_cid ON student(age, name, classId);
```

```mysql
EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE student.age = 30 AND student.classId > 20 AND student.name = 'abc';
```

![image-20230823183725640](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230823183725640.png)

---

**补充：**

1. 范围查询包含：大于等于、大于、小于等于、小于、between。
2. 在开发中的范围查询：金额、日期往往都是范围查询，创建联合索引时考虑放在后面。

## 不等于导致索引失效

```mysql
# 创建索引
CREATE INDEX idx_name ON student(name);
```

```mysql
EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE student.name != 'abc';
```

![image-20230823185242898](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230823185242898.png)

**结论：无解。**

## IS NOT NULL导致索引失效

```mysql
EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE age IS NULL;
```

```mysql
EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE age IS NOT NULL;
```

![image-20230823185756215](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230823185756215.png)

**结论：**使用IS NOT NULL会导致索引失效，在设计数据表的时候就将字段设置为**NOT NULL 约束**。

**扩展：**同理，在查询中使用**NOT LIKE**也无法使用索引，会导致全表扫描。

## LIKE以通配符%开头导致索引失效

在使用**LIKE**进行模糊查询中，如果匹配字符串的第一个字符为**%**，索引就不会起作用。只有**%**不在第一个位置，索引才会起作用。

> 拓展：Alibaba《Java开发手册》
> 【强制】页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决。  

## OR前后存在非索引列导致索引失效

OR的含义就是**多个中只要满足一个**即可，因此只要有条件列中没有索引，就会进行全表扫描，因此索引的条件列也会失效。

```mysql
EXPLAIN SELECT name, stuno FROM student WHERE name = 'abc' OR stuno = 100001;
```

![image-20230823191934966](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230823191934966.png)

虽然name列有索引，但没办法使用上，下面给name和stuno都添加上索引。

```mysql
CREATE INDEX idx_name_stuno ON student(name, stuno);
```

```mysql
EXPLAIN SELECT name, stuno FROM student WHERE name = 'abc' OR stuno = 100001;
```

![image-20230823192240218](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230823192240218.png)

## 字符集转换导致索引失效

**不同的字符集**进行比较前需要进行**转换**会造成索引失效，**强制**建议同一个数据库中的所有表统一字符集。

# 关联查询优化

## 数据准备

1. 创建表

   ```mysql
   # 分类表
   CREATE TABLE IF NOT EXISTS `type`(
   `id` INT(10) UNSIGNED NOT NULL AUTO_INCREMENT,
   `card` INT(10) UNSIGNED NOT NULL,
   PRIMARY KEY ( `id` )
   );
   ```

   ```mysql
   # 图书表
   CREATE TABLE IF NOT EXISTS `book`(
   	`bookid` INT(10) UNSIGNED NOT NULL AUTO_INCREMENT,
       `card`INT(10) UNSIGNED NOT NULL,
   	PRIMARY KEY (`bookid`)
   );
   ```

2. 添加数据

   ```mysql
   # 向分类表中添加20条记录
   INSERT INTO type (card) VALUES (FLOOR(1 +(RAND() * 20)));
   ```

   ```mysql
   # 向图书表中添加20条记录
   INSERT INTO book(card) VALUES (FLOOR(1 +(RAND() * 20)));
   ```

## 左外查询

```mysql
EXPLAIN SELECT SQL_NO_CACHE * FROM `type` LEFT JOIN book ON type.card = book.card;
```

![image-20230823211440733](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230823211440733.png)

添加索引

```mysql
CREATE INDEX idx_card ON book(card);
```

```mysql
# 再次查看执行计划
EXPLAIN SELECT SQL_NO_CACHE * FROM `type` LEFT JOIN book ON type.card = book.card;
```

![image-20230823211759173](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230823211759173.png)

可以看到第二行的type为**ref**，rows也有明显的优化，这是由**左连接**特性决定的。连接条件是用于确定如何从右表搜索行，左边表数据一定都有，所以右边表是关键点，一定需要建立索引。

----

如果给驱动被添加索引会怎么样？

```mysql
CREATE INDEX idx_card ON `type`(card);
```

```mysql
EXPLAIN SELECT SQL_NO_CACHE * FROM `type` LEFT JOIN book ON type.card = book.card;
```

![image-20230824001634875](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230824001634875.png)

## 内查询

1. 前置知识

   ![image-20230829202602958](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230829202602958.png)
   
   **book表为驱动表，type表为被驱动表。**
   
1. 删掉之前添加的索引

   ```mysql
   drop index idx_card on type;
   drop index idx_card on book;
   ```
   
3. 使用**inner join**进行查询

   ```mysql
   EXPLAIN SELECT SQL_NO_CACHE * FROM `type` LEFT JOIN book ON type.card = book.card;
   ```

   ![image-20230829203113161](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230829203113161.png)

4. 给**book**表添加索引后再查询

   ```mysql
   create index idx_card on book(card);
   
   EXPLAIN SELECT SQL_NO_CACHE * FROM `type` LEFT JOIN book ON type.card = book.card;
   ```

   ![image-20230829203549273](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230829203549273.png)

   > book表变成**被驱动表**。

5. 继续给type表添加索引后再查询

   ```mysql
   create index idx_card on type(card);
   
   EXPLAIN SELECT SQL_NO_CACHE * FROM `type` LEFT JOIN book ON type.card = book.card;
   ```

   ![image-20230829203354065](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230829203354065.png)

6. 结论：
   1. **内连接**被驱动表是由优化器决定的，优化器认为哪个成本比较小，就采用那个表作为驱动表。
   2. 如果两张表**只有一个有索引**，那有索引的表作为**被驱动表**。原因：驱动表要全查，有没有索引都要全查。
   3. 两个索引都存在的情况下， 数据量大的作**被驱动表**（小表驱动大表）。原因：驱动表要全查，而大表可以通过索引加快查找。

## 关联查询原理

join方式连接多个表，本质就是各个表之间数据的循环匹配。MySQL5.5欣本之刖，MySQL只文持一种表间关联方式，就是嵌套循环(Nested Loop Join)。如果关联表的数据量很大，则join关联的执行时间会非常长。在MySQL5.5以后的版本中，MySQL通过引入**BNLJ算法**来优化嵌套执行。

### 驱动表与被驱动表

1. 在内连接查询中，驱动表和被驱动表都是由优化器决定的。
2. 在左外连接查询中，驱动表是左表，被驱动表是右表。
3. 在右外连接查询中，驱动表是右表，被驱动表是左表。

### Simple Nested-Loop Join（简单嵌套循环连接）

算法相当简单，从驱动表中取出一条数据，遍历整个被驱动表，将匹配到的数据放到结果集中，以此类推，驱动表中的每一条记录都要与被驱动表的记录进行判断：

![简单嵌套循环连接](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/%E7%AE%80%E5%8D%95%E5%B5%8C%E5%A5%97%E5%BE%AA%E7%8E%AF%E8%BF%9E%E6%8E%A5.svg)

上图例子是没有索引的情况，做了全表扫描。可以看到这种方式效率是非常低的，假设表A数据有100条，表B数据有1000条计算，则A * B = 10万次。开销统计：

| 开销统计         | BNLJ  |
| ---------------- | ----- |
| 外表扫描次数     | 1     |
| 内表扫描次数     | A     |
| 读取记录数       | A+A*B |
| JOIN比较次数     | B*A   |
| 回表读取记录次数 | 0     |

### Index Nested-Loop Join（索引嵌套循环连接）

Index Nested-Loop Join的思路主要是为了**减少内层表数据的匹配次数**，要求被驱动表上必须**有索引**。通过外层表匹配条件直接与内层表索引进行匹配，避免和内层表的每条记录去进行比较，这样极大的减少了对内层表的匹配次数。

![索引嵌套循环连接](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/%E7%B4%A2%E5%BC%95%E5%B5%8C%E5%A5%97%E5%BE%AA%E7%8E%AF%E8%BF%9E%E6%8E%A5.svg)

驱动表中的每条记录通过被驱动表的索引进行访问，因为索引查询的成本是比较固定的，故mysql优化器都倾向于使用记录数少的表作为驱动表。开销统计：

| 开销统计         | BNLJ  | INLJ                  |
| ---------------- | ----- | --------------------- |
| 外表扫描次数     | 1     | 1                     |
| 内表扫描次数     | A     | 0                     |
| 读取记录数       | A+A*B | A+B(math)             |
| JOIN比较次数     | B*A   | A*Index(Height)       |
| 回表读取记录次数 | 0     | B(math) (if possible) |

如果被驱动表已添加索引，效率是非常高的。如果被驱动表的索引不是主键索引，需要进行一次回表查询，如果是主键索引，不需要进行回表查询，效率会更高。

### Block Nested-Loop Join（块嵌套循环连接）

1. 如果存在索引，那么会使用index的方式进行join，如果join的列没有索引，被驱动表要扫描的次数太多。每次访问被驱动表，其表中的记录都会被加载到内存中，然后再从驱动表中取一条与其匹配，匹配结束后清除内存，然后再从驱动表中加载一条记录，然后把被驱动表的记录在加载到内存匹配这样周而复始，大大增加了I/O的次数。为了减少被驱动表的I/O次数，就出现了Block Nested-Loop Join的方式。

2. Block Nested-Loop Join的方式不再是**逐条**获取驱动表的数据，而是一块一块的获取，引入了**join buffer缓冲区**，将**驱动表join**相关的部分数据列（大小受join buffer的限制）缓存到join buffer中，然后全表扫描被驱动表的每—条记录—次性和**join buffer**中的所有驱动表记录进行匹配（**内存中操作**)，将简单嵌套循环中的多次比较合并成一次，降低了被驱动表的访问频率。

   ![块嵌套循环连接](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/%E5%9D%97%E5%B5%8C%E5%A5%97%E5%BE%AA%E7%8E%AF%E8%BF%9E%E6%8E%A5.svg)

3. 注意：

   1. 缓存的不只是关联表的列，select语句后的列也会缓存起来，缓存的是驱动表的列。
   2. 在一个有N个join关联的SQL中会分配N-1个join buffer。所以在查询时，尽量减少不必要的字段，可以让join buffer中可以存放更多的列。

4. 开销统计：

   | 开销统计         | BNLJ  | INLJ                  | BNLJ                                           |
   | ---------------- | ----- | --------------------- | ---------------------------------------------- |
   | 外表扫描次数     | 1     | 1                     | 1                                              |
   | 内表扫描次数     | A     | 0                     | A*used_column_size / join_buffer_size+1        |
   | 读取记录数       | A+A*B | A+B(math)             | A+B* (A*used_column_size / join_buffer_size+1) |
   | JOIN比较次数     | B*A   | A*Index(Height)       | B*A                                            |
   | 回表读取记录次数 | 0     | B(math) (if possible) | 0                                              |

5. 相关参数设置：

   1. block_nested_loop：查看block_nested_loop状态，默认是开启的。

      ```mysql
      show variables like '%optimizer_switch%';
      ```

      ![image-20230829220401373](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230829220401373.png)

   2. join_buffer_size：缓冲区大小。驱动表能否一次加载完，要看join buffe能否存储所有的数据，默认情况下**join_buffer_size=256k**。

      ```mysql
      show variables like '%join_buffer%';
      ```

      

      ![image-20230829220540581](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230829220540581.png)

      > 注意：join_buffer_size的最大值在32位系统可以电请4G，而在64位操做系统下可以申请大于4G的Join Buffer空间（64位Windows除外，超过其最大值会被截断为4GB并发出警告）。

### 原理总结

1. 效率比较：**INLJ > BNLJ > SNLJ**。
2. 遵循**使用小结果集驱动大结果集**的原则，本质就是减少外层循环的数据数量。
3. 为被驱动表匹配的条件增加索引，减少内层表的循环匹配次数。
4. 增大join buffer size的大小，一次缓存的数据越多，那么内层包的扫表次数就越少。
5. 减少驱动表不必要的字段查询，字段越少，join buffer能够缓存的数据就越多。
6. 在决定哪个表做驱动表的时候，先是两个表按照各自的条件过滤，过滤完成之后，计算参与join的各个字段的总数据量，数据量小的那个表作为驱动表。

## 关联查询总结

1. 保证被驱动表的JOIN字段已创建索引。
2. 需要JOIN 的字段，数据类型需保持一致。
3. 外连接查询时，选择小表作为驱动表， 大表作为被驱动表，减少外层循环的次数。
4. INNER JOIN时，MySQL会自动将**小结果集的表选为驱动表**。
5. 能够直接多表关联的尽量直接关联，不要使用子查询。
6. 不建议使用子查询，建议将子查询SQL拆开结合程序多次查询，或使用连接查询来代替子查询。
7. 衍生表（临时表）是无法创建索引的。

## 补充：Hash Join

从MySQL的8.0.20版本开始将废弃BNLJ，因为从MySQL8.0.18版本开始就加入hash join，并且默认都会使用hash join。

Nested Loop：对于被连接的数据子集较小的情况，Nested Loop是个较好的选择。

Hash Join：做**大数据集**连接时的常用方式，优化器使用两个表中较小（相对较小）的表利用Join Key在内存中建立**散列表**，然后扫描较大的表并探测散列表，找出与Hash表匹配的行。

1. 这种方式适用于较小的表完全可以放于内存中的情况，总成本就是访问两个表的成本之和。
2. 在表数据量很大的情况下并不能完全放入内存，这时优化器会将它分割成**若干不同的分区**，不能放入内存的部分就把该分区写入磁盘的临时段，此时要求有较大的临时段从而尽量提高I/O的性能。
3. 能够很好的工作于没有索引的大表和并行查询的环境中，并提供最好的性能。Hash Join**只能**应用于**等值连接**，这是由Hash的特点决定的。

| 类别     | Nested Loop                                                  | Hash Join                                                    |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 使用条件 | 任何条件                                                     | 等值连接                                                     |
| 相关资源 | CPU、硬盘I/O                                                 | 内存、临时空间                                               |
| 特点     | 当有高选择性索引或进行限制性搜索时效率比较高，能够快速返回第一次的搜索结果 | 当缺乏索引或者索引条件模糊时，Hash Jointt比Nested Loop高效。在数据仓库环境下，如果表的纪录数多，效率高。 |
| 缺点     | 当索引丢失或者查询条件限制不够时，效率很低；当表的纪录数多时，效率低。 | 为建立哈希表，需要大畫内存。第一次的结果返回较慢。           |

# 子查询优化

**子查询的执行效率不高，原因：**

1. 执行子查询时MySQL需要为内层查询语句的查询结果**建立临时表**，然后外层查询语句从临时表中查询记录。查询完毕后，再**撤销临时表**。这样会消耗过多的CPU和IO资源，产生大量的慢查询。
2. 子查询的结果集存储的临时表，不论是内存临时表还是磁盘临时表都是没有索引的，所以查询性能会受到一定的影响。
3. 返回结果集较大的子查询，对查询性能的影响较大。

在查询时可以使用连接查询来替代子查询，连接查询不需要**建立临时表**，比子查询要快，如果查询时使用索引的情况下，性能更高。

---

举例1：查询学生表中是班长的学生信息

* 创建索引

  ```mysql
  # 创建班级表中班长的索引
  CREATE INDEX idx_monitor ON class(monitor);
  ```

* 使用子查询

  ```mysql
  EXPLAIN SELECT * FROM student stu WHERE stu.stuno IN(SELECT monitor FROM class c WHERE monitor IS NOT NULL);
  ```

* 使用连接查询（推荐使用）

  ```mysql
  EXPLAIN SELECT * FROM student stu INNER JOIN class c ON stu.stuno = c.monitor WHERE c.monitor IS NOT NULL;

---

举例2：查询学生表中不是班长的学生信息

* 使用子查询，非常不推荐使用

  ```mysql
  EXPLAIN SELECT SQL_NO_CACHE stu.* FROM student AS stu WHERE stu.stuno NOT IN (SELECT monitor FROM class b WHERE monitor IS NOT NULL);
  ```

* 使用连接查询（推荐使用）

  ```mysql
  EXPLAIN SELECT SQL_NO_CACHE stu.* FROM student AS stu LEFT JOIN class AS c ON stu.stuno = c.monitor WHERE c.monitor iS NULL;
  ```

----

**结论：**尽量不要使用 NOT IN 或 NOT EXISTS，用 LEFT JOIN xxx ON xx WHERE xx IS NULL 替代。

# 排序优化

## 排序优化

问题：在WHERE条件字段上添加索引，为什么在**ORDER BY**字段上还需要添加索引呢？

回答：在MySQL中，支持两种排序方式，分别是**FileSort**和**Index**排序。

* Index排序中，索引可以保证数据的有序性，**不需要再进行排序**，效率更高。
* FileSort排序一般在**内存中**进行排序，占用CPU和内存资源较多。如果待排结果较大，会产生临时文件到磁盘进行排序的情况，效率较低。

---

优化建议：

1. SQL中，可以在WHERE子句和ORDER BY子句中使用索引，目的是在WHERE子句中**避免全表扫描**，在ORDER BY子句**避免使用FileSort排序**。当然，某些情况下全表扫描或FileSort排序不一定比索引慢。但总的来说，还是要避免，以提高查询效率。
2. 尽量使用Index完成ORDER BY排序。如果WHERE和ORDER BY后面是**相同**的列就使用单索引列，如果**不同**则使用联合索引。
3. 在无法使用Index时，需要对FileSort方式进行调优。

## 测试验证

准备工作：删除student表和class表中创建的索引。

```mysql
DROP INDEX idx_age_classid_name ON student;
DROP INDEX idx_age_name_cid ON student;
DROP INDEX idx_name ON student;
DROP INDEX idx_age_stuno ON student;
DROP INDEX idx_name_stuno ON student;

DROP INDEX idx_monitor ON class;
```

1. 阶段一：

   ```mysql
   EXPLAIN SELECT SQL_NO_CACHE * FROM student ORDER BY age,classid;
   
   EXPLAIN SELECT SQL_NO_CACHE * FROM student ORDER BY age,classid limit 10;
   ```

   ![image-20230830171618272](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230830171618272.png)

2. 阶段二： ORDER BY时不LIMIT，导致无法使用索引

   ```mysql
   # 创建索引
   CREATE INDEX idx_age_classid_name ON student(age,classid,name);
   ```

   ```mysql
   # 不使用LIMIT查询
   EXPLAIN SELECT SQL_NO_CACHE * FROM student ORDER BY age,classid;
   ```

   ![image-20230830171828752](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230830171828752.png)

   > 这里优化器认为需要回表，使用索引反而效率更低，所以不使用索引。

   ---

   使用覆盖索引，避免回表操作

   ```mysql
   EXPLAIN SELECT SQL_NO_CACHE age,classid FROM student ORDER BY age,classid;
   ```

   ![image-20230830172258153](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230830172258153.png)

   ---

   增加LIMIT查询，减少回表次数，优化器觉得效率更高，所以使用索引。

   ```mysql
   EXPLAIN SELECT SQL_NO_CACHE * FROM student ORDER BY age,classid LIMIT 10;
   ```

   ![image-20230830172418836](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230830172418836.png)

3. 阶段三：ORDER BY时列索引错误，导致无法使用索引

   ```mysql
   # 创建索引
   CREATE INDEX idx_age_classid_stuno ON student(age,classid,stuno);
   ```

   ---

   无法使用索引的情况：

   ```mysql
   # 没有遵循最左前缀原则
   EXPLAIN SELECT* FROM student ORDER BY classid LIMIT 10;
   
   EXPLAIN SELECT* FROM student ORDER BY classid,name LIMIT 10;
   ```

   ![image-20230830173035071](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230830173035071.png)

   能够使用索引的情况：

   ```mysql
   EXPLAIN SELECT * FROM student ORDER BY age,classid,stuno LIMIT 10;
   
   EXPLAIN SELECT *FROM student ORDER BY age,classid LIMIT 10;
   
   EXPLAIN SELECT * FROM student ORDER BY age LIMIT 10;
   ```

   ![image-20230830173406895](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230830173406895.png)

4. 阶段四：ORDER BY时规则不一致，导致无法使用索引（顺序错、方向反）

   ```mysql
   # 排序顺序与索引的顺序不一致，导致索引
   EXPLAIN SELECT * FROM student ORDER BY age DESC, classid ASC LIMIT 10;
   ```

   ![image-20230830173842365](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230830173842365.png)

   ```mysql
   # 没有遵循最左前缀原则
   EXPLAIN SELECT * FROM student ORDER BY classid DESC,name DESC LIMIT 10;
   ```

   ![image-20230830174008245](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230830174008245.png)

   ```mysql
   EXPLAIN SELECT * FROM student ORDER BY age ASC, classid DESC LIMIT 10;
   ```

   ![image-20230830174101967](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230830174101967.png)

   > 排序顺序与索引的顺序不一致，优化器认为，文件排序比索引快，所以导致索引失效。

   ```mysql
   EXPLAIN SELECT * FROM student ORDER BY age DESC, classid DESC LIMIT 10; 
   ```

   ![image-20230830174341762](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230830174341762.png)

   > 排序顺序与索引的顺序都相反，会倒着使用索引。

5. 阶段五：WHERE子句和ORDER BY子句共同使用联合索引

   ```mysql
   EXPLAIN SELECT * FROM student WHERE age=45 ORDER BY classid;
   
   EXPLAIN SELECT * FROM student WHERE age=45 ORDER BY classid,name;
   ```

   ![image-20230830175111146](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230830175111146.png)

   ```mysql
   EXPLAIN SELECT * FROM student WHERE classid=45 order by age;
   
   EXPLAIN SELECT * FROM student WHERE classid=45 order by age limit 10;
   ```

   ![image-20230830175238116](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230830175238116.png)

   > 第一条查询排序使用Using filesort是因为优化器认为使用索引需要回表，反而效率更低。
   >
   > 第二条查询为什么没有使用Using filesort进行排序呢？
   >
   > 优化器预估对idx_age_classid_name 索引进行完整的遍历，由于索引本身就是根据age升序存储的，所以只要在遍历过程中，遇到前十条classid=45的记录，就可以停止遍历，回表返回数据。

---

结论：

1. 每个SELECT语句只能使用一个索引，WHERE子句和ORDER BY子句需要共用一个索引，但**可以使用联合索引**。

2. 如果SELECT语句中没有WHERE子句，ORDER BY子句的列必须遵循最左前缀原则，否则可能会导致索引失效。

3. 如果WHERE子句使用索引的最左前缀定义为**常量**，则ORDER BY能使用索引。

   ```mysql
   # 索引
   INDEX a_b_c(a, b, c)
   
   WHERE a = const ORDER BY b, c
   WHERE a = const AND b = const ORDER BY c
   WHERE a = const ORDER BY b, c
   WHERE a = const AND b > const ORDER BY b, c
   ```

4. 无法使用索引进行排序的情况：

   ```mysql
   # 索引
   INDEX a_b_c(a, b, c)
   
   # 排序顺序不一致
   ORDER BY a ASC, b DESC, c DESC
   
   # 没有遵循最左前缀原则
   WHERE g = const ORDER BY b,c
   WHERE a = const ORDER BY c
   
   # 排序列不是索引列（d）
   WHERE a = const ORDER BY a, d
   
   # 多个相等条件也是范围查询，WHERE子句使用索引的最左前缀定义为常量，ORDER BY才能使用索引
   WHERE a in (...) ORDER BY b,c
   ```

## 案例实战

目的：ORDER BY子句，尽量使用Index方式排序，避免使用FileSort方式排序。

准备工作：清除student上的索引，只保留主键索引。

```mysql
# 查看表中已创建的索引
show index from student;

# 删除索引
DROP INDEX idx_age_classid_name ON student;
DROP INDEX idx_age_name_cid ON student;
DROP INDEX idx_name ON student;
DROP INDEX idx_age_stuno ON student;
DROP INDEX idx_name_stuno ON student;
DROP INDEX idx_age_classid_stuno ON student;
```

场景：查询年龄为30岁的，且学生编号小于101000的学生，按用户名称排序。

```mysql
EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE age = 30 AND stuno < 101000 ORDER BY name;
```

![image-20230830181820252](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230830181820252.png)

> 结论：type是ALL，最坏的情况；Extra还出现Using filesort，也是最坏的情况，必须进行优化。

优化方案一：创建索引去掉Using filesort。

```mysql
CREATE INDEX idx_age_name ON student(age, name);

EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE age = 30 AND stuno < 101000 ORDER BY name;
```

![image-20230830182455454](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230830182455454.png)

优化方案二：尽量让WHERE的过滤条件和排序都使用上索引。

```mysql
CREATE INDEX idx_age_stuno_name ON student(age, stuno, name);

EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE age = 30 AND stuno < 101000 ORDER BY name;
```

![image-20230830182632951](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230830182632951.png)

> 这个方案虽然使用 Using filesort进行排序， 但是速度反而更快，原因：
>
> 所有的排序都是在条件过滤之后才执行的，如果条件过滤掉大部分数据，剩下的数据进行排序其实并不是很消耗性能，即使索引优化排序，但实际提升性能很有限。相较于stuno<101000这个条件，如果没有使用索引的话，要对大量的数据进行扫描，这是非常消耗性能的，所以索引放在这个字段上性价比最高，是最优选择。

---

结论：

1. 两个索引同时存在，MySQL会自动选择最优的。但随着数据量的变化，选择的索引也会随之变化的。
2. 当范围条件和GROUP BY或ORDER BY的字段出现二选一的情况，优先观察条件字段的过滤数量，如果过滤的数据足够多，而需要排序的数据并不多时，优先把索引放在范围字段上，反之亦然。

## filesort算法：双路排序和单路排序

排序的字段如果不在索引列上，则**filesort**会有两种算法：**双路排序**和**单路排序**。

**双路排序（慢）**

1. **MySQL 4.1之前是使用双路排序**，字面意思就是两次扫描磁盘，最终得到数据，读取行指针和ORDER BY列，对它们进行排序，排序好之后再从磁盘中获取其他列的数据。
2. 获取一批数据，要对磁盘进行**两次**扫描，众所周知，I/O是很耗时的，所以在MySQL 4.1之后，引入了**单路排序。**

**单路排序（快）**

1. 从磁盘读取查询需要的**所有列**，按照ORDER BY列在buffer对它们进行排序，但是这样会使用更多的空间。因为一次性将数据从磁盘读取到内存中，避免了二次读取数据，并且把随机I/O变成顺序I/O，记录都保存在内存中。

---

**结论及引申出的问题：**

* 由于单路排序是后引入的，总体而言好过双路排序。
* 单路排序存在的问题：
  1. 在**sort_buffer**中，单路比多路要**占用更多空间**，因为单路是把所有列都读取到内存中，所以有可能读取的数据的总大小超出**sort_buffer**的容量，导致每次只能取**sort_buffer**容量大小的数据进行排序（创建临时文件，多路合并)，排完再取**sort_buffer**容量大小的数据再进行排序，以此反复，从而多次I/O。
  2. 单路本来想省一次I/O操作，**反而导致了大量的I/O操作**，得不偿失。

**优化策略：**

1. 提高**sort_buffer_size**的容量。

   不管使用哪种算法，提高这个参数的值都会提高效率，要根据系统的能力去增加，因为这个参数是针对每个进程（connection）。建议在1M~8M之间调整，在MySQL5.7的InnoDB存储引擎默认值是1048576字节（1MB）。

   ```mysql
   SHOW VARIABLES LIKE '%sort_buffer_size%';
   ```

   <img src="https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230830185618080.png" alt="image-20230830185618080" style="zoom: 75%;" />

2. 提高**max_length_for_sort_data**。

   提高这个参数的值，会增加使用改进算法的概率。

   ```mysql
   SHOW VARIABLES LIKE '%max_length_for_sort_data%';
   ```

   <img src="https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230830185851927.png" alt="image-20230830185851927" style="zoom:75%;" />

   > 注意；如果值设的太高，数据总容量超出**sort_buffer_size**，概率就会提高，明显症状是高的磁盘I/O活动和低的处理器使用率。如果需要返回的列的总长度大于**max_length_for_sort_data**使用**双路算法**，否则使用**单路算法**。建议在1024-8192字节之间调整。

4. ORDER BY时SELECT * 是一个大忌，最好只查询需要的字段，原因：
   1. 当查询的字段大小总和小于**max_length_for_sort_data**，而且排序字段不是TEXT|BLOB类型时，会使用单路排序，否则使用多路排序。
   2. 两种算法的数据都有可能超出**sort_buffer_size**的容量，超出之后，会创建临时文件进行合并排序，导致多次I/O。但是使用单路排序算法的风险会更大一些，所以要**提高sort_buffer_size**。

# GROUP BY优化

1. GROUP BY使用索引的原则几乎跟ORDER BY一致，GROUP BY即使**没有过滤条件用到索引**，也可以直接使用索引。
2. GROUP BY**排序后再分组**，遵循最佳左前缀法则。
3. 当无法使用索引列时，增大**max_length_for_sort_data**和**sort_buffer_size**参数的值。
4. WHERE效率高于HAVING，能在WHERE限定的条件就不要写在HAVING中。
5. 减少使用ORDER BY，业务中能不排序就不排序。DISTINCT
6. ORDER BY、GROUP BY、DISTINCT这些语句较耗费性能，建议减少使用。
7. 包含ORDER BY、GROUP BY、DISTINCT这些查询的语句，WHERE条件过滤出来的结果集请保持在1000行内，否则SQL会很慢。

# 分页查询优化

一般分页查询时，通过创建覆盖索引能够比较好地提高性能。但存在一个较为头疼的问题，如：**LIMIT 2000000, 10**，此时需要排序前2000010条记录，仅仅返回2000000~2000010的记录，其他记录丢弃，查询排序的代价非常大。

1. 优化思路一：在索引上完成分页操作，最后根据主键关联回原表查询所需要的其他列内容。

   ```mysql
   EXPLAIN SELECT * FROM student stu, (SELECT id FROM student ORDER BY id LIMIT 2000000,10) t WHERE stu.id = t.id;
   ```

   ![image-20230830202111158](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230830202111158.png)

2. 优化思路二：适用于主键自增的表，可以把LIMIT查询转换成某个位置的查询。

   ```mysql
   EXPLAIN SELECT * FROM student WHERE id >= 2000000 LIMIT 10;
   ```
   
   ![image-20230830203608043](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230830203608043.png)
   
   > 不靠谱，生产环境中id可能会被删除，查询的条件也不可能这么简单。

# 覆盖索引

## 什么是覆盖索引

**理解方式一：**索引是高效找到行的一个方法，但是一般也能使用索引找到一个列的数据，因此不必回表读取整个行，毕竟索引叶子节点存储了索引的数据，当能通过读取索引得到想要的数据时，就不需要回表读取整个行。一个索引包含了满足查询结果的数据就叫做覆盖索引。
**理解方式二：**非聚簇联合索引的一种形式，它包括在查询里的SELECT、JOIN和WHERE子句中用到的所有列（即索引的字段正好是覆盖这些子句中所涉及的字段）。

## 举例说明

准备工作：删除student表已创建的索引。

```mysql
# 查看已创建的索引
SHOW INDEX FROM student;
# 删除索引
DROP INDEX idx_age_name ON student;
DROP INDEX idx_age_stuno_name ON student;
```

准备工作：添加索引

```mysql
CREATE INDEX idx_age_name ON student (age, name);
```

---

**举例1：**

```mysql
EXPLAIN SELECT * FROM student WHERE age <> 20;
```

![image-20230831161852186](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230831161852186.png)

```mysql
EXPLAIN SELECT id, age, name FROM student WHERE age <> 20;
```

![image-20230831161950864](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230831161950864.png)

```mysql
EXPLAIN SELECT id, age, name, classid FROM student WHERE age <> 20;
```

![image-20230831162213216](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230831162213216.png)

> 需要查询的列不在索引中，如果使用索引需要回表获取，反而比全表扫描效率更低。

----

**举例2：**

```mysql
EXPLAIN SELECT * FROM student WHERE name LIKE '%abc';
```

![image-20230831162403166](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230831162403166.png)

```mysql
EXPLAIN SELECT id, age, name FROM student WHERE name LIKE '%abc';
```

![image-20230831162618557](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230831162618557.png)

> 之前有说过，左模糊会导致索引失效，这里能够使用上索引是因为要查询的列刚好都在索引上，直接遍历索引就可以返回数据，遍历索引肯定比遍历全表数据量少的。

```mysql
EXPLAIN SELECT id, age, name, classid FROM student WHERE name LIKE '%abc';
```

![image-20230831163110770](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230831163110770.png)

> 需要查询的列不在索引中，如果使用索引需要回表获取，反而比全表扫描效率更低。

## 覆盖索引的利弊

**好处：**

1. **避免Innodb表进行索引的二次查询（回表）**。Innodb是以聚集索引的顺序来存储的，对于Innodb来说，二级索引在叶子节点中所保存的是行的主键信息，如果是用二级索引查询数据，在查找到相应的键值后，还需通过主键进行二次查询才能获取所需要的数据。
2. **把随机I/O变成顺序I/O加快查询效率**。由于覆盖索引是顺序存储的，对于I/O密集型的范围查找来说，对比随机从磁盘读取每一行的数据I/O要少的多，因此利用覆盖索引在访问时也可以把磁盘的**随机读取的I/O**转变成索引查找的**顺序I/O**。

3. **数据在索引里面数据量少更紧凑**。索引比表中的数据量更少，可以减少I/O。
4. **覆盖索引可以减少树的搜索次数，显著提升查询性能，是一个常用的性能优化手段。**

---

**弊端：**索引的**维护**总是有代价的。因此，在建立冗余索引来支持覆盖索引时就需要权衡考虑。

# 字符串添加索引

准备工作：创建一张教师表。

```mysql
CREATE TABLE teacher(
	id bigint unsigned primary key,
	email varchar(64)
)ENGINE=innodb;
```

## 前缀索引

MySQL是支持前缀索引的。默认情况下，如果创建索引时不指定前缀长度，那么索引就会包含整个字符串。

```mysql
CREATE INDEX idx_email ON teacher(email);
# 或
CREATE INDEX idx_email_6 ON teacher(email(6));

# 查看索引
SHOW INDEX FROM teacher;
```

![image-20230831165107644](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230831165107644.png)

这两种不同的定义在数据结构和存储上有什么区别呢？

![idx_email2](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/idx_email2.svg)

![idx_email_6](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/idx_email_6.svg)



假设现在要查询email的值是`zhangssxyz@xxx.com`的记录，它们的执行顺序是怎么样的。

```mysql
EXPLAIN SELECT * FROM teacher WHERE email = 'zhangssxyz@xxx.com';
```

**使用idx_email的执行顺序：**

1. 从idx_email索引树中找到满足索引值是`zhangssxyz@xxx.com `的记录，取得主键值。
2. 通过主键值回主键索引中获取所需的数据，将记录加入到结果集中。
3. 继续在idx_email索引树上查找下一条记录，如果索引值不是`zhangssxyz@xxx.com `则结束，如果是则重复上面的步骤。
4. 整个执行过程中，只需要回主键索引获取一次数据。

**使用idx_email_6的执行顺序：**

1. 从idx_email_6索引树中找到满足索引值是`zhangs `的记录，取得主键值。
2. 通过主键值回主键索引中获取对应的行，判断email值是否是`zhangssxyz@xxx.com `，如果不是则丢弃，如果是则放入到结果集中。
3. 继续在idx_email_6索引树上查找下一条记录，如果索引值不是`zhangs `则结束，如果是则重复上面的步骤。

**结论：**前缀索引是可以做到既节省空间，又不用额外增加太多的查询成本。

## 前缀索引对覆盖索引的影响

在前缀索引中是无法使用覆盖索引的，在对查询性能优化时，这也是选择是否使用前缀索引需考虑的一个因素。

# 索引下推

## 概述

1. Index Condition Pushdown（ICP）是MySQL 5.6中新特性，是一种在存储引擎层使用索引过滤数据的一种**优化方式**。
2. 如果没有ICP，存储引擎会遍历索引以定位基表中的行，并将它们返回给MySQL，由MySQL通过WHERE条件判断是否保留行。
3. 启用ICP后，如果部分WHERE条件仅使用索引中的列进行筛选，则MySQL会把这部分WHERE条件放到存储引擎筛选。然后，存储引擎通过使用索引来筛选数据，并且只有在满足这一条件时才从表中读取行。
4. ICP可以减少存储引擎必须访问基表的次数和MySQL必须访问存储引擎的次数。但是，ICP的加速效果取决于在存储引擎内通过**ICP筛选**掉的数据比例。

## ICP的开启/关闭

1. 默认情况下是**启用索引条件下推**的。可以通过设置系统变量**optimizer_switch**来开启/关闭。

   ```mysql
   # 开启索引下推
   SET optimizer_switch = 'index_condition_pushdown=off';
   # 关闭索引下推
   SET optimizer_switch = 'index_condition_pushdown=on';
   ```

2. 当使用索引条件下推时，**EXPLAIN**语句输出结果中Extra列内容显示为**Using index condition**。

## ICP的使用案例

1. 创建表。

   ```mysql
   CREATE TABLE `people` (
   	`id` INT NOT NULL AUTO_INCREMENT,
   	`zipcode` VARCHAR (20),
   	`firstname` varchar(20),
   	`lastname` varchar(20),
   	`address` varchar (50),
   	PRIMARY KEY ( `id`),
   KEY `idx_zip_last_first`( `zipcode` , `lastname`, `firstname`)
   )ENGINE=InnoDB;
   ```

2. 插入数据

   ```mysql
   INSERT INTO `people` VALUES('1', '000001','三','张','北京市'),('2', '000002','四','李','南京市'),('3', '000003', '五','王','上海市'),('4', '000001','六','赵','天津市');
   ```

3. 定义了联合索引**idx_zip_last_first (zipcode，lastname，firstname)**。如果已知一个人的邮编，但不确定这个人的姓氏，可以进行如下检索：

   ```mysql
   EXPLAIN SELECT * FROM people WHERE zipcode= '000001' AND lastname LIKE '%张%' AND address LIKE '%北京市%';
   ```

   ![image-20230831175334210](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230831175334210.png)

   > 执行计划中的Extra中**Using index condition**表示使用了索引下推。另外，**Using where**表示条件中包含需要过滤的非索引列的数据，即address LIKE '%北京市%'这个条件并不是索引列。

## 开启和关闭ICP的性能对比

1. 创建存储过程插入很多000001的数据。

   ```mysql
   DELIMITER //
   CREATE PROCEDURE insert_people( max_num INT )
   BEGIN
   DECLARE i INT DEFAULT 0;
   	SET autocommit = 0;
   	REPEAT
   	SET i = i + 1;
   	INSERT INTo people ( zipcode, firstname , lastname , address ) VALUES ( '000001','六', '赵','天津市');
   
   	UNTIL i = max_num
   	END REPEAT;
   	COMMIT;
   END //
   DELIMITER ;
   ```

2. 调用存储过程。

   ```mysql
   CALL insert_people(1000000);
   ```

3. 首先开启**profiling**，默认是关闭的。

   ```mysql
   # 查看
   show variables like 'profiling%';
   # 开启
   set profiling = 1;
   ```

5. 执行SQL，默认时打开索引下推的。

   ```mysql
   SELECT * FROM people WHERE zipcode = '000001' AND lastname LIKE '%张%';
   ```

   ![](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230831180457513.png)

6. 再次执行SQL，不使用索引下推。

   ```mysql
   SELECT /*+ no_icp (people) */ * FROM people WHERE zipcode = '000001' AND lastname LIKE '%张%';
   ```

   ![image-20230831180545282](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230831180545282.png)

7. 查看当前会话所产生的所有profiles。

   ```mysql
   show profiles\G;
   ```

   ![image-20230831180716126](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230831180716126.png)

   > 多次测试效率对比分析，使用ICP优化的查询效率会好一些。

## 使用前后的扫描过程

**不使用ICP索引扫描的过程：**

storage层：只将满足index key条件的索引记录对应的整行记录读取出来，返回给server层。

server层：对返回的数据，使用WHRER条件过滤，直至返回最后一行。

![在不使用ICP索引扫描的过程3](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/%E5%9C%A8%E4%B8%8D%E4%BD%BF%E7%94%A8ICP%E7%B4%A2%E5%BC%95%E6%89%AB%E6%8F%8F%E7%9A%84%E8%BF%87%E7%A8%8B3.svg)

![在不使用ICP索引扫描的过程B树3](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/%E5%9C%A8%E4%B8%8D%E4%BD%BF%E7%94%A8ICP%E7%B4%A2%E5%BC%95%E6%89%AB%E6%8F%8F%E7%9A%84%E8%BF%87%E7%A8%8BB%E6%A0%913.svg)

**使用ICP扫描的过程：**

storage层：首先将index key条件满足的索引记录区间确定，然后在索引上使用index filter进行过滤，将满足index filter条件的索引记录回表取出整行记录返回server层。不满足index filter条件的索引记录丢弃，不回表也不返回server层。
server 层：对返回的数据，使用table filter条件做最后的过滤。  

![使用ICP扫描的过程](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/%E4%BD%BF%E7%94%A8ICP%E6%89%AB%E6%8F%8F%E7%9A%84%E8%BF%87%E7%A8%8B.svg)

![使用ICP扫描的过程B树](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/%E4%BD%BF%E7%94%A8ICP%E6%89%AB%E6%8F%8F%E7%9A%84%E8%BF%87%E7%A8%8BB%E6%A0%91.svg)

**使用前后的成本差别：**

1. 使用前，存储层多返回需要被index filter过滤掉的整行记录。
2. 使用ICP后，直接就去掉了不满足index filter条件的记录，省去了回表和传递到server层的成本。
3. **ICP的加速效果**取决于在存储引擎内通过**ICP筛选**掉的数据比例。

##  ICP的使用条件

1. 如果表访问的类型为range、ref、eq_ref和ref_or_null可以使用ICP。

2. ICP可以用于**InnoDB**和**MyISAM**表，包括分区表**InnoDB**和**MyISAM**表。

3. 对于**InnoDB**表，**ICP**仅用于二级索引。ICP的目的是**减少全行读取次数**，从而减少I/O操作。

4. 当使用覆盖索引时，不支持ICP。因为这种情况下使用ICP不会减少I/O，索引覆盖是不需要回表的，ICP作用是减少回表，ICP需要回表。

5. **相关子查询**的条件不能使用ICP。

# 普通索引对比唯一索引

**从性能的角度考虑，选择唯一索引还是普通索引的依据是什么呢？**

假设，有一个主键列为id的表，表中有字段k，并且在k上有索引，假设字段k上的值都不重复。

```mysql
CREATE TABLE test(
  id int primary key,
  k int not null,
  name varchar(16),
  index (k)
)ENGINE=InnoDB;
```

往表中插入数据。

```mysql
INSERT INTO  test(id, k) VALUES(100, 1),(200,2),(300,3),(500,5),(600,6);
```

## 查询过程

假设，当前要执行查询的语句是：

```mysql
SELECT id FROM test where k = 5;
```

1. 对于普通索引来说，查找到满足条件的记录后，需要继续查找下一条记录，直到碰到第一个不满足条件的记录。
2. 对于唯一索引来说，由于索引定义了唯一性，查找到第一个满足条件的记录后，就会停止查找。
3. 那么，这个不同带来的性能差距是**微乎其微**的。

## 更新过程

为了了解普通索引和唯一索引对更新性能的影响，需要先了解一下**change buffer**：

1. 当需要更新一个数据页时，如果数据页在内存中就直接更新，而如果这个数据页还没有在内存中的话，在不影响数据一致性的前提下， **InooDB会将这些更新操作缓存在change buffer中**，这样就不需要从磁盘中读取这个数据页。在下次查询需要访问这个数据页的时，将数据页读入内存，然后执行change buffer中与这个页有关的操作。通过这种方式就能保证这个数据逻辑的正确性。
2. 将change buffer中的操作应用到原数据页，得到最新结果的过程称为**merge** 。除了**访问这个数据页会触发merge外**，MySQL**后台线程会定期merge。**在**数据库正常关闭（shutdown）**的过程中，也会执行merge操作。
3. 如果能够将更新操作先记录在change buffer， **减少读磁盘** ，SQL的执行速度会得到明显的提升。而且，数据读入内存是需要占用**buffer pool**的，所以这种方式还**能够避免占用内存** ，提高内存利用率。
4. **唯一索引的更新是无法使用change buffer**，实际上也只有普通索引可以使用。

## change buffer的使用场景

1. 普通索引和唯一索引应该怎么选择？其实，这两类索引在查询能力上是没差别的，主要考虑的是对**更新性能**的影响，所以，建议**尽量选择普通索引**。
2.  在实际使用中会发现，**普通索引**和**change buffer**的配合使用，对于**数据量大**的表的更新优化还是很明显的。
3. 如果在所有的更新后面，都马上**伴随着对这个记录的查询** ，那么应该**关闭change buffer** 。而在其他情况下，change buffer都能提升更新性能。
4. 由于唯一索引用不上change buffer的优化机制的，如果业务可以接受，从性能角度出发建议**优先考虑非唯一索引**。但如果**业务可能无法确保**的情况下，该怎么处理呢？
   1. 首先，保证业务正确性优先 。前提是**业务代码已经保证不会写入重复数据**的情况下再讨论性能问题。如果业务无法保证或者业务就是要求数据库来做约束，那么没得选，必须创建唯一索引。
   2. 本节的意义在于，如果碰上大量插入数据慢、内存命中率低的时候，多提供一个**排查思路**。
5. 在一些**归档库**的场景，可以考虑使用唯一索引的。比如，线上数据只需要保留半年，然后历史数据保存在归档库。这时，归档数据已经是确保没有唯一键冲突。要提高归档效率，可以考虑把表中的唯一索引改成普通索引。  

# 其他查询优化策略

## EXISTS和IN的区分

**问题：**在什么样的情况下选择使用EXISTS还是IN，选择的标准是看能否使用表的索引吗？

**回答：**索引是个前提，其实是否选择还是要看表数据量的大小。可以将选择的标准理解为**小表驱动大表**，在这种方式下效率是最高的。比如：

```mysql
SELECT * FROM A WHERE cc IN(SELECT cc FROM B)

SELECT * FROM A WHERE EXISTS(SELECT cc FROM B WHERE B.cc = A.cc)
```

当A小于B时，用EXISTS，因为EXISTS的实现，相当于外表循环，实现的逻辑类似于：

```mysql
for i in A
	for j in B
		if j.cc == i.cc then ...
```


当B小于A时用IN，因为实现的逻辑类似于：

```mysql
for i in B
	for j in A
		if j.cc == i.cc then ...
```

## COUNT(*)与COUNT(具体字段)效率

**问题：** 在MySQL中统计数据表的行数时，可以使用三种方式：**SELECT COUNT(*)**、**SELECT COUNT(1)**和**SELECT COUNT(具体字段)**，这三者之间的查询效率如何？

**回答：**

1. 前提，如果要统计的是某个字段的**非空数据行数**，则另当别论，毕竟比较执行效率的前提是结果一样才可以。
2. **COUNT(*)**和**COUNT(1)**都是对所有结果进行**COUNT**，**COUNT(*)**和**COUNT(1)**本质上并没有区别，可能二者执行时间可能略有差别，不过还是可以把它们的执行效率看成是相等的。如果有WHERE子句，则是对所有符合筛选条件的数据行进行统计，如果没有WHERE子句，则是对数据表的所有数据行数进行统计。
3. 如果是**MyISAM**存储引擎，统计数据表的行数只需要**O(1)**的复杂度，这是因为每张MyISAM的数据表都有一个meta信息存储**row_count**变量，而一致性则由**表级锁**来保证。
4. 如果是InnoDB存储引擎，因为InnoDB支持事务，采用行级锁和MVCC机制，所以无法像MyISAM一样维护一个row_count变量，因此需要**扫描全表**，使用的是循环计数的方式来完成统计的，需要O(n) 的复杂度。
5. 在InnoDB引擎中，如果采用**COUNT(具体字段)**来统计数据行数，要尽量采用二级索引。因为主键采用的索引是聚簇索引，聚簇索引包含的信息多，明显会大于二级索引（非聚簇索引）。对于**COUNT(*)**和**COUNT(1)**来说，不需要查找具体的行，只是统计行数，系统会**自动**采用占用空间更小的二级索引来进行统计。
6. 如果有多个二级索引，会使用**key_len**小的二级索引来进行扫描，当没有二级索引的时，才会采用主键索引来进行统计。

## 关于SELECT *

在查询时，建议明确字段，不要使用*****作为查询的字段列表，原因：

1. MySQL在解析的过程中，会通过**查询数据字典**将*****按序转换成所有列名，会耗费资源和时间。
2. **无法使用覆盖索引**。

## LIMIT 1 对优化的影响

1. 针对的是会**扫描全表**的SQL语句，如果可以确定结果集只有一条，那么加上**LIMIT 1**时，当找到一条结果就不会继续扫描，这样会加快查询的速度。
2. 如果表中已对字段建立了**唯一索引**，那么可以**通过唯一索引进行查询**，不会全表扫描的情况是不需要加**LIMIT 1**的。

# 主键设计方案