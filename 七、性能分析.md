# 优化步骤

<img src="https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/%E4%BC%98%E5%8C%96%E6%AD%A5%E9%AA%A42.svg" alt="优化步骤2" style="zoom:80%;" />

> 整个流程划分成观察（Show status）和行动（Action）两个部分。
>
> 字母 S 的部分代表观察（会使用相应的分析工具），字母 A 代表的部分是行动（对应分析可以采取的行动）。

<img src="https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/%E6%9C%80%E4%BD%8E%E7%9A%84%E6%88%90%E6%9C%AC%E8%BE%BE%E5%88%B0%E6%9C%80%E9%AB%98%E7%9A%84%E6%95%88%E6%9E%9C.svg" alt="最低的成本达到最高的效果" style="zoom:125%;" />

> 目标：最低的成本达到最高的效果。

# 查看系统性能参数

```mysql
# 查看 性能参数、执行频率
SHOW [GLOBAL|SESSION] STATUS LIKE'参数';
```

常用的性能参数：

| 参数                 | 说明                                   |
| -------------------- | -------------------------------------- |
| Connections          | 连接MySQL服务器的次数                  |
| Uptime               | MySQL服务器的上线时间                  |
| Slow_queries         | 慢查询的次数                           |
| Innodb_rows_read     | Select查询返回的行数                   |
| Innodb_rows_inserted | 执行INSERT操作插入的行数               |
| Innodb_rows_updated  | 执行UPDATE操作更新的行数               |
| Innodb_rows_deleted  | 执行DELETE操作删除的行数               |
| Com_select           | 查询操作的次数                         |
| Com_insert           | 插入操作的次数。批量插入，只累加一次。 |
| Com_update           | 更新操作的次数                         |
| Com_delete           | 删除操作的次数                         |

# 统计查询成本

一条SQL查询语句在执行前需要确定查询执行计划，如果存在多种执行计划的话，MySQL会计算每个执行计划所需要的成本，从中选择**成本最小**的一个作为最终执行的执行计划。

```mysql
# 在执行查询sql之后执行,值的单位为数据页
SHOW STATUS LIKE 'last_query_cost';
```

> 使用场景：对于比较开销是非常有用的，特别是有好几种查询方式可选的时候。
>
> 注意：查询的时间差不多一样，但查询成本可能会存在很大的差距。

# 定位慢SQL

## 开启慢查询日志

1. **开启slow_query_log。**

   ```mysql
   # 开启
   set global slow_query_log='ON';
   
   # 查看开启状态和慢查询日志文件的位置
   show variables like '%slow_query_log%';
   ```

   ![image-20230816003825607](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230816003825607.png)

2. **修改long_query_time阈值，默认为10s。**

   ```mysql
   show variables like '%long_query_time%';
   
   # 全局
   set global long_query_time = 1;
   show global variables like '%long-query_time%';
   
   # 会话
   set long_query_time=1;
   show variables like '%long_query_time%';
   ```

   > 注意：设置global的方式对当前session的long_query_time是没生效的，对新连接的客户端才有效。可以一并行上述语句。

   ![image-20230816004637823](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230816004637823.png)

3. **补充：通过配置文件设置。**

   1. 配置文件的方式相较于前面的命令行方式，可以看作是永久设置的方式。

   2. 在**my.cnf**文件**[mysqld]**下增加或修改参数**long_query_time**、**slow_query_log**和**slow_query_log_file**，保存重启MySQL服务。

      ```properties
      [mysqld]
      # 开启慢查询日志
      slow_query_log=ON 
      # 慢查询日志的目录和文件名
      slow_query_log_file=/var/lib/mysql/my-slow.log
      # 设置慢查询的阈值为3秒，超出此设定值的SQL即被记录到慢查询日志
      long_query_time=3 
      log_output=FILE
      ```

      > * 如果不指定存储路径，慢查询日志将默认存储到MySQL数据库的数据文件夹下。
      > * 如果不指定文件名，默认文件名为hostname-slow.log。

## 查看慢查询数目

开启慢SQL查询日志后，可通过以下命令查询当前系统中有多少条慢查询记录。

```mysql
SHOW GLOBAL STATUS LIKE '%Slow_queries%';
```

![image-20230816005529974](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230816005529974.png)

## 慢查询案例

1. 建表

   ```mysql
   CREATE TABLE `student` (
   `id` INT(11) NOT NULL AUTO_INCREMENT,
   `stuno` INT NOT NULL ,
   `name` VARCHAR(20) DEFAULT NULL,
   `age` INT(3) DEFAULT NULL,
   `classId` INT(11) DEFAULT NULL,
   PRIMARY KEY (`id`)
   ) ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;

2. 设置参数log_bin_trust_function_creators

   如果在创建函数时报错：This function has none of DETERMINISTIC......，可以使用命令开启创建函数设置。

   ```mysql
   # global
   set global log_bin_trust_function_creators=1;
   # session
   set log_bin_trust_function_creators=1;
   ```

3. 创建函数

   **随机产生字符串**

   ```mysql
   DELIMITER //
   CREATE FUNCTION rand_string(n INT)
   	RETURNS VARCHAR(255) #该函数会返回一个字符串
   BEGIN
       DECLARE chars_str VARCHAR(100) DEFAULT
       'abcdefghijklmnopqrstuvwxyzABCDEFJHIJKLMNOPQRSTUVWXYZ';
       DECLARE return_str VARCHAR(255) DEFAULT '';
       DECLARE i INT DEFAULT 0;
   	WHILE i < n DO
           SET return_str =CONCAT(return_str,SUBSTRING(chars_str,FLOOR(1+RAND()*52),1));
           SET i = i + 1;
   	END WHILE;
   	RETURN return_str;
   END //
   DELIMITER ;
   
   # 测试
   SELECT rand_string(10);
   ```

   ---

   **随机产生数值**

   ```mysql
   DELIMITER //
   CREATE FUNCTION rand_num (from_num INT ,to_num INT) RETURNS INT(11)
   BEGIN
   DECLARE i INT DEFAULT 0;
   SET i = FLOOR(from_num +RAND()*(to_num - from_num+1)) ;
   RETURN i;
   END //
   DELIMITER ;
   
   # 测试
   SELECT rand_num(10,100);
   ```

4. 创建存储过程

   ```mysql
   DELIMITER //
   CREATE PROCEDURE insert_stu( START INT , max_num INT )
   BEGIN
   DECLARE i INT DEFAULT 0;
       # 设置手动提交事务
       SET autocommit = 0;
       # 循环
       REPEAT 
        # 赋值
       SET i = i + 1;
       INSERT INTO student (stuno, NAME ,age ,classId ) VALUES
       ((START+i),rand_string(6),rand_num(10,100),rand_num(10,1000));
       UNTIL i = max_num
       END REPEAT;
       # 提交事务
       COMMIT;
   END //
   
   DELIMITER ;
   ```

5. 调用存储过程

   ```mysql
   CALL insert_stu(100001,4000000);
   ```

   > 4000000条记录，从100001号开始。

## 慢查询案例测试及分析

1. **测试**

   ```mysql
   SELECT * FROM student WHERE stuno = 3455655;
   ```

   ![image-20230816012439388](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230816012439388.png)

   ---

   ```mysql
   SELECT * FROM student WHERE name = 'EfLrAA';
   ```

   ![image-20230816012651448](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230816012651448.png)

   > 通过观察上诉的查询测试结果，已经达到秒的数量级，说明目前查询效率是比较低的，下面的小节分析一下原因  。

2. **分析**

   ```mysql
   # 查看慢查询数目
   show status like 'slow_queries';
   ```

   ![image-20230816012829930](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230816012829930.png)

   > **补充说明:**
   >
   > 除了上述变量，控制慢查询日志的还有一个系统变量：**min_examined_row_limit**。这个变量的意思是，查询**扫描过的最少记录数**。这个变量和查询执行时间，共同组成判断一个查询是否是慢查询的条件。如果查询扫描过的记录数大于等于这个变量的值，并且查询执行时间超过**long_query_time**的值，那么，这个查询就被记录到慢查询日志中。

## 慢查询日志分析工具：mysqldumpslow

1. 在生产环境中，如果要手工分析日志，查找、分析SQL，显然是个体力活，MySQL提供一个日志分析工具：**mysqldumpslow** 。

2. 查看mysqldumpslow的帮助信息

   ```shell
   mysqldumpslow --help
   ```

3. 命令可选参数（option）说明：

   1. -a：不将数字抽象成N，字符串抽象成S。
   2. **-s：表示按照何种方式排序**：
      - c：访问次数
      - l：锁定时间
      - r：返回记录
      - **t：查询时间**
      - al：平均锁定时间
      - ar：平均返回记录数
      - at：平均查询时间 （默认方式）
      - ac：平均查询次数
   3. **-t:：即为返回前面多少条的数据。**
   4.   **-g:：搭配一个正则匹配模式，大小写不敏感**  

4. 举例：按照查询时间排序，查看前五条**慢SQ**L语句：

   ```shell
   mysqldumpslow -a -s t -t 10 /usr/local/mysql/data/localhost-slow.log
   ```

   ![image-20230816020448241](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230816020448241.png)

5. **工作常用参考：**

   ```shell
   # 记录集最多的10个SQL
   mysqldumpslow -s r -t 10 /var/lib/mysql/atguigu-slow.log
   
   # 访问次数最多的10个SQL
   mysqldumpslow -s c -t 10 /var/lib/mysql/atguigu-slow.log
   
   # 按照时间排序的前10条里面含有左连接的查询语句
   mysqldumpslow -s t -t 10 -g "left join" /var/lib/mysql/atguigu-slow.log
   
   # 另外建议在使用这些命令时结合 | 和 more 使用，否则有可能出现爆屏情况
   mysqldumpslow -s r -t 10 /var/lib/mysql/atguigu-slow.log | more
   ```

## 关闭慢查询日志

1. **除了调优需要开，正常建议不要开启。**

2. 临时性方式关闭

   ```mysql
   SET GLOBAL slow_query_log=off;
   ```

3. **my.cnf**配置文件方式关闭

   ```properties
   [mysqld]
   # 注释掉或删除
   # slow_query_log=OFF
   ```

   > 修改配置文件后，需要重启MySQL服务。

## 删除慢查询日志

1. 查看慢查询日志文件存储的位置

   ```mysql
   show variables like '%slow_query_log%';
   ```

   ![image-20230816021356065](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230816021356065.png)

2. 从执行结果可以看出，慢查询日志的目录默认为MySQL的数据目录，在该目录下**手动删除慢查询日志文件**即可。

3. 使用命令重新生成慢查询日志文件。

   ```shell
   mysqladmin -uroot -p flush-logs slow
   ```

   > 注意：
   >
   > 1. 如果不使用命令生成，是没办法自动创建的。
   > 2. 一旦执行这个命令，慢查询日志都只存在新的日志文件中，如果需要旧的查询日志，就必须事先备份。
   > 3. 这个命令还可以重置其它日志，例如：undo日志。

# 查看慢SQL执行成本：SHOW PROFILE

1. SHOW PROFILE是MySQL提供的可以用来分析当前会话中**SQL都做了什么、执行的资源消耗情况**的工具，可用于SQL调优的分析。**默认情况下处于关闭状态**，并保存最近15次的运行结果。

2. 开启SHOW PROFILE功能

   ```mysql
   # 查看
   show variables like 'profiling';
   # 开启
   set profiling = 'ON';
   ```

   ![image-20230816022709096](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230816022709096.png)

3. 使用SHOW PROFILE命令

   ```mysql
   show profiles;
   ```

   ![image-20230816023247792](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230816023247792.png)

4. 查看最近一次查询的开销

   ```mysql
   show profile;
   ```

   <img src="https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230816023412938.png" alt="image-20230816023412938" style="zoom:70%;" />

5. 通过Query lD查看指定的开销，还可以查看不同部分的开销，比如cpu、block io等。

   ```mysql
   show profile cpu,block io for query 7;
   ```

   ![image-20230816023808019](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230816023808019.png)

6. **常用查询参数：**

   | 参数             | 描述                                                         |
   | ---------------- | ------------------------------------------------------------ |
   | ALL              | 显示所有的开销信息                                           |
   | BLOCK IO         | 显示块IO开销                                                 |
   | CONTEXT SWITCHES | 上下文切换开销                                               |
   | CPU              | 显示CPU开销信息                                              |
   | IPC              | 显示发送和接收开销信息                                       |
   | MEMORY           | 显示内存开销信息                                             |
   | PAGE FAULTS      | 显示页面错误开销信息                                         |
   | SOURCE           | 显示和Source_function，Source_file，Source_line相关的开销信息 |
   | SWAPS            | 显示交换次数开销信息                                         |

7. 日常开发需注意的结论：
   1. **converting HEAP to MyISAM**：查询结果太大，内存不够，数据往磁盘保存。
   2. **creating tmp table**：创建临时表，先拷贝数据到临时表，用完后再删除临时表。
   3. **Copying to tmp table on disk**：把内存中临时表复制到磁盘上，警惕。
   4. **locked**。
   5. 如果在show profile诊断结果中出现以上4条结果中的任何一条，则sql语句需要优化。
8. **注意**：SHOW PROFILE命令**将**被弃用，可以从information_schema中的profiling数据表进行查看。

# 分析查询：EXPLAIN

## 概述

1. **定位到查询慢的SQL之后，就可以使用EXPLAIN或DESCRIBE工具做针对性的分析查询语句。**DESCRIBE语句的使用方法与EXPLAIN语句是一样的，并且分析结果也是一样的。
2. MySQL中有专门负责优化SELECT语句的优化器模块，主要功能:：通过计算分析系统中收集到的统计信息，为客户端请求的Query提供它认为最优的**执行计划**（它认为最优的数据检索方式，但不见得是DBA认为是最优的，这部分最耗费时间)。
3. 这个执行计划展示具体执行查询的方式，比如：多表连接的顺序是什么，对于每个表采用什么访问方法来具体执行查询等等。
4. EXPLAIN的作用：查看表的读取顺序、数据读取操作的操作类型、哪些索引可以使用、**哪些索引被实际使用**、表之间的引用、**每张表有多少行被优化器查询**。
5. 官方介绍：[mysql5.7](https://dev.mysql.com/doc/refman/5.7/en/explain-output.html)、[mysql8.0](https://dev.mysql.com/doc/refman/8.0/en/explain-output.html  )。

6. **版本情况说明：**

   1. MySQL 5.6.3以前只能 EXPLAIN SELECT，MYSQL 5.6.3以后就可以 EXPLAIN SELECT / UPDATE / DELETE。

   2. 在5.7以前的版本中，想要显示**partitions**需要使用**explain partitions**命令，想要显示**filtered** 需要使用explain extended命令。在5.7版本后，默认explain直接显示partitions和filtered中的信息。  

      ![image-20230816044300027](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230816044300027.png)

## 基本语法

1. EXPLAIN 或 DESCRIBE 语句的语法形式如下：

   ```mysql
   EXPLAIN SELECT select_options
   # 或者
   DESCRIBE SELECT select_options
   ```

   举例：

   ```mysql
   EXPLAIN SELECT * FROM student LIMIT 0, 10;
   ```

   ![image-20230816044732973](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230816044732973.png)

2. EXPLAIN输出的各个列的作用：

   | 列名          | 描述                                                   |
   | ------------- | ------------------------------------------------------ |
   | id            | 在一个查询语句中每个SELECT关键字都对应一个 唯一的id    |
   | select_type   | SELECT关键字对应的那个查询的类型                       |
   | table         | 表名                                                   |
   | partitions    | 匹配的分区信息                                         |
   | **type**      | 针对单表的访问方式                                     |
   | possible_keys | 可能用到的索引                                         |
   | **key**       | **实际上使用的索引**                                   |
   | **key_len**   | **实际使用到的索引长度**                               |
   | ref           | 当使用索引列等值查询时，与索引列进行等值匹配的对象信息 |
   | **rows**      | **预估需要读取的记录数**                               |
   | filtered      | 经过搜索条件过滤后剩余记录条数的百分比                 |
   | **Extra**     | 一些额外的信息                                         |

## 数据准备

1. **建表**

   ```mysql
   CREATE TABLE s1 (
   	id INT AUTO_INCREMENT,
   	key1 VARCHAR(100), 
   	key2 INT, 
   	key3 VARCHAR(100), 
   	key_part1 VARCHAR(100),
   	key_part2 VARCHAR(100),
   	key_part3 VARCHAR(100),
   	common_field VARCHAR(100),
   	PRIMARY KEY (id),
   	INDEX idx_key1 (key1),
   	UNIQUE INDEX idx_key2 (key2),
   	INDEX idx_key3 (key3),
   	INDEX idx_key_part(key_part1, key_part2, key_part3)
   ) ENGINE=INNODB CHARSET=utf8;
   ```

   ```mysql
   CREATE TABLE s2 (
       id INT AUTO_INCREMENT,
       key1 VARCHAR(100),
       key2 INT,
       key3 VARCHAR(100),
       key_part1 VARCHAR(100),
       key_part2 VARCHAR(100),
       key_part3 VARCHAR(100),
       common_field VARCHAR(100),
       PRIMARY KEY (id),
       INDEX idx_key1 (key1),
       UNIQUE INDEX idx_key2 (key2),
       INDEX idx_key3 (key3),
   	INDEX idx_key_part(key_part1, key_part2, key_part3)
   ) ENGINE=INNODB CHARSET=utf8;
   ```

2. **设置参数 log_bin_trust_function_creators**

   如果创建函数**报错**，需开启允许创建函数设置。

   ```mysql
   # 当前session有效
   set global log_bin_trust_function_creators=1;
   ```

3.  创建函数

   ```mysql
   DELIMITER //
   # 函数功能：返回一个随机字符串
   CREATE FUNCTION rand_string1 ( n INT ) 
   	RETURNS VARCHAR (255) 
   BEGIN
   	DECLARE
   		chars_str VARCHAR (100) DEFAULT 'abcdefghijklmnopqrstuvwxyzABCDEFJHIJKLMNOPQRSTUVWXYZ';
   	DECLARE
   		return_str VARCHAR (255) DEFAULT '';
   	DECLARE
   		i INT DEFAULT 0;
   	WHILE
   			i < n DO
   			
   			SET return_str = CONCAT(
   				return_str,
   			SUBSTRING( chars_str, FLOOR( 1+RAND ()* 52 ), 1 ));
   		
   		SET i = i + 1;
   		
   	END WHILE;
   	RETURN return_str;
   	
   END // 
   DELIMITER ;
   ```

4. 创建存储过程

   ```mysql
   # 往s1表中插入数据的存储过程
   DELIMITER //
   CREATE PROCEDURE insert_s1 (IN min_num INT (10),IN max_num INT (10))
   BEGIN
       DECLARE i INT DEFAULT 0;
       SET autocommit = 0;
       REPEAT
       SET i = i + 1;
       INSERT INTO s1 VALUES(
       (min_num + i),
       rand_string1(6),
       (min_num + 30 * i + 5),
       rand_string1(6),
       rand_string1(10),
       rand_string1(5),
       rand_string1(10),
       rand_string1(10));
       UNTIL i = max_num
       END REPEAT;
       COMMIT;
   END //
   DELIMITER ;
   ```

   ```mysql
   # 往s2表中插入数据的存储过程
   DELIMITER //
   CREATE PROCEDURE insert_s2 (IN min_num INT (10),IN max_num INT (10))
   BEGIN
       DECLARE i INT DEFAULT 0;
       SET autocommit = 0;
       REPEAT
       SET i = i + 1;
       INSERT INTO s2 VALUES(
       (min_num + i),
       rand_string1(6),
       (min_num + 30 * i + 5),
       rand_string1(6),
       rand_string1(10),
       rand_string1(5),
       rand_string1(10),
       rand_string1(10));
       UNTIL i = max_num
       END REPEAT;
       COMMIT;
   END //
   DELIMITER ;
   ```

5. 调用存储过程

   ````mysql
   # 往s1表中插入1万条记录，id从10002到20001
   CALL insert_s1(10001,10000);
   ````

   ```mysql
   # 往s2表中插入1万条记录，id从10002到20001
   CALL insert_s2(10001,10000);
   ```

## EXPLAIN各列的作用

下面对EXPLAIN输出列的介绍与EXPLAIN实际输出的顺序有所调整，主要是为了方便对EXPLAIN的了解，

### 1、table

1. 不论查询语句有多复杂，包含多少个表，到最后也是需要对每个表进行 单表访问的，所以EXPLAIN语句输出的每条记录都对应着每个单表的访问方法，该条记录的table列代表着该表的表名（有时不是真实的表名字，可能是简称）。

2. 举例说明：

   ```mysql
   explain select count(*) from s1;
   ```

   ![image-20230816051429711](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230816051429711.png)

   ---

   ```mysql
   # s1：驱动表  s2：被驱动表
   EXPLAIN SELECT * FROM s1 INNER JOIN s2;
   ```

   ![image-20230816051718826](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230816051718826.png)

   > 1. 在连接查询时，驱动表和被驱动表是**优化器**决定的。
   > 2. 查询语句中用到多少张表，就会有多少条记录。

### 2、id

1. 在正常情况下，一个SELECT语句就有一个id，也有存在例外的情况，可能是查询优化器做了优化。

2. 举例说明：**正常情况**

   ```mysql
   EXPLAIN SELECT * FROM s1 WHERE key1 = 'a';
   ```

   ![image-20230816052424837](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230816052424837.png)

   ---

   ```mysql
   EXPLAIN SELECT * FROM s1 INNER JOIN s2;
   ```

   ![image-20230816052719130](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230816052719130.png)

   ---

   ```mysql
   EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2) OR key3 = 'a';
   ```

   ![image-20230816052835733](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230816052835733.png)

   > 注意：**正常情况下**子查询也是一个SELECT语句，总之就是查询语句中出现一个SELECT关键字就有一个对应的id。

3. 举例说明：**查询优化器优化**

   ```mysql
   EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key2 FROM s2 WHERE common_field = 'a');
   ```

   ![image-20230816053252948](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230816053252948.png)

   > 运行结果中，id只有一个，是因为查询优化器做了优化。

4. 举例说明：**UNION查询**

   ```mysql
   # UNION去重
   EXPLAIN SELECT * FROM s1 UNION SELECT * FROM s2;
   ```

   ![image-20230816053734303](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230816053734303.png)

   ---

   ```mysql
   # UNION ALL不去重
   EXPLAIN SELECT * FROM s1 UNION ALL SELECT * FROM s2;
   ```

   ![image-20230816053910405](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230816053910405.png)

   > UNION ALL查询不需要去重，则不需要产生临时表。

5. 总结：
   1. id值越大，优先级越高，越先执行。
   2. 如果id相同，可认为是一组，从上往下顺序执行。
   3. 结论：**每一个不同的id都表示一次独立的查询，一个SQL语句的查询次数越少越好**。

### 3、select_type

1. 在一条**大**的查询语句中可以包含**若干个**SELECT关键字，每个SELECT关键字代表着一个**小**的查询语句，而每个SELECT关键字的**FROM子句**中都可以包含**若干张表**，每一张表都对应着执行计划输出中的一条记录，对于在同一个SELECT关键字中的表来说，它们的id值是相同的。

2. MySQL为每一个SELECT关键字代表的**小查询**都定义一个称之为**select_type**的属性，意思就是只要知道某个**小查询**的**select_type**属性，就可以知道这个**小查询**在整个**大查询**中扮演着一个什么样的角色。

3. select_type有很多取值，具体如下或参考官方文档：

   | select_type Value    | JSON Name                  | Meaning                                                      |
   | :------------------- | :------------------------- | :----------------------------------------------------------- |
   | SIMPLE               | None                       | Simple SELECT(not using UNION or subqueries)                 |
   | PRIMARY              | None                       | Outermost SELECT                                             |
   | UNION                | None                       | Second or later SELECTstatement in a UNION                   |
   | DEPENDENT UNION      | dependent (true)           | Second or later SELECTstatement in a UNION, dependent on outer query |
   | UNION RESULT         | union_result               | Result of a UNION.                                           |
   | SUBQUERY             | None                       | First SELECTin subquery                                      |
   | DEPENDENT SUBQUERY   | dependent (true)           | First SELECTin subquery, dependent on outer query            |
   | DERIVED              | None                       | Derived table                                                |
   | DEPENDENT DERIVED    | dependent (true)           | Derived table dependent on another table                     |
   | MATERIALIZED         | materialized_from_subquery | Materialized subquery                                        |
   | UNCACHEABLE SUBQUERY | cacheable (false)          | A subquery for which the result cannot be cached and must be re-evaluated for each row of the outer query |
   | UNCACHEABLE UNION    | cacheable (false)          | The second or later select in a UNION that belongs to an uncacheable subquery (see UNCACHEABLE SUBQUERY) |

---

4. **SIMPLE**：

   1. 查询语句中不包含**UNION**或者**子查询**的查询都算作是SIMPLE类型。

      ```mysql
      EXPLAIN SELECT * FROM s1;
      ```

   2. 连接查询也算是SIMPLE类型。

      ```mysql
      EXPLAIN SELECT * FROM s1 INNER JOIN s2;
      ```

---

5. **PRIMARY、UNION、UNION RESULT**：

   1. MySQL选择使用临时表来完成**UNION查询**的去重工作，针对该临时表的查询的**select_type**就是**UNION RESULT**。

   2. 对于包含UNION、UNION ALL或子查询的**大查询**来说，它是由几个**小查询**组成的，其中最左边的那个小查询的**select_type**值是**PRIMARY**，其余的小查询是**UNION**。

   3. 举例说明：

      ```mysql
      EXPLAIN SELECT * FROM s1 UNION SELECT * FROM s2;	
      ```

      ![image-20230816061630827](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230816061630827.png)

      ---

      ```mysql
      EXPLAIN SELECT * FROM s1 UNION ALL SELECT * FROM s2;
      ```

      ![image-20230816061718344](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230816061718344.png)

----

6. **SUBQUERY：**

   1. 如果包含子查询的查询语句不能够转为对应的**semi-join**的形式，并且该子查询是**不相关子查询**，并且查询优化器决定采用将该子查询**物化**的方案来执行该子查询时，则该子查询的**第一个**SELECT关键字对应的那个查询的**select_type**就是 **SUBQUERY**。

   2. 举例说明：

      ```mysql
      EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2) OR key3 = 'a';
      ```

      ![image-20230816062246530](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230816062246530.png)

----

7. **DEPENDENT SUBQUERY：**

   1. 如果包含子查询的查询语句不能够转为对应的**semi-join**的形式，并且该子查询是**相关子查询**，则该子查询的第一个SELECT关键字代表的那个查询的**select_type**就是**DEPENDENT SUBQUERY**。

   2. 举例说明：

      ```mysql
      EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2 WHERE s1.key2 = s2.key2) OR key3 = 'a';
      ```

      ![image-20230816062816721](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230816062816721.png)

---

8. **DEPENDENT UNION：**

   1. 在包含UNION或者UNION ALL的**大查询**中，如果各个小查询都依赖于外层查询的话，除了**最左边**的那个**小查询**之外，其余的小查询的**select_type**值就是**DEPENDENT UNION**。

   2. 举例说明：

      ```mysql
      EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2 WHERE key1 = 'a' UNION SELECT key1 FROM s1 WHERE key1 = 'b');
      ```

      ![image-20230816063646707](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230816063646707.png)

---

9. **DERIVED**：

   1. 对于包含**派生表**的查询，该**派生表**对应的**子查询**的**select_type**值就是**DERIVED**。

   2. 举例说明：

      ```mysql
      EXPLAIN SELECT * FROM (SELECT key1, COUNT(*) AS c FROM s1 GROUP BY key1) AS derived_s1 WHERE c > 1;
      ```

      ![image-20230816064027853](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230816064027853.png)

---

10. **MATERIALIZED**：

    1. 当查询优化器在执行包含子查询的语句时，选择将子查询**物化**之后与外层查询进行连接查询时，该子查询对应的**select_type**值就是**MATERIALIZED**。

    2. 举例说明：

       ```mysql
       EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2);
       ```

       ![image-20230816064416476](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230816064416476.png)

---

11. **UNCACHEABLE SUBQUERY、UNCACHEABLE UNION**：不常用，这里不做说明。

### 4、partitions（可忽略）

1. 在分区表中才有意义，如果想了解，可以创建分区表来进行测试：

   ```mysql
   CREATE TABLE user_partitions (
       id INT auto_increment,
       NAME VARCHAR(12),PRIMARY KEY(id))
       PARTITION BY RANGE(id)(
       PARTITION p0 VALUES less than(100),
       PARTITION p1 VALUES less than MAXVALUE
   );
   ```

   > 说明：按照id进行分区，id小于100在p0分区，其余的都是在p1分区。

2. 测试查询：

   ```mysql
   EXPLAIN SELECT * FROM user_partitions WHERE id<100;
   
   EXPLAIN SELECT * FROM user_partitions WHERE id>=100;
   ```

   ![image-20230816065811705](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230816065811705.png)

### 5、type（重点）

1. 执行计划的一条记录就代表着MySQL对某个表的**执行查询时的访问方法**，又称"访问类型”，其中的**type**列用于说明这个访问方法是啥，是较为**重要**的一个指标。
2. 完整的访问方法： **system、const、eq_ref、ref、fulltext、ref_or_null、index_merge、unique_subquery、 index_subquery、range、 index、ALL **。

---

3. **system**：

   1. 当表中**只有一条记录**并且该表使用的存储引擎的统计数据是精确的，比如MyISAM、Memory，那么对该表的访问方法就是**system**。

   2. 举例说明：新建一个**MyISAM**表，并为其插入一条记录。

      ```mysql
      # 建表
      CREATE TABLE t(i int) Engine=MyISAM;
      
      # 插入一条记录
      INSERT INTO t VALUES(1);
      ```

      ```mysql
      EXPLAIN SELECT * FROM t;
      ```

      ![image-20230816071208358](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230816071208358.png)

      > 注意：如果是 innoDB 会变成ALL ， 因为innoDB不会存记录数量，而MyISAM会存储。

---

4. **const**：

   1. 根据主键或者唯一二级索引列与**常数**进行等值匹配时，访问方法就是**const**。

   2. 举例说明：

      ```mysql
      EXPLAIN SELECT * FROM s1 WHERE id = 10005;
      
      EXPLAIN SELECT * FROM s1 WHERE key2 = '10066';
      ```

      ![image-20230816071731719](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230816071731719.png)

---

5. **eq_ref**：

   1. 在连接查询时，如果被驱动表是通过主键或者唯一二级索引列等值匹配的方式进行访问的（如果该主键或者唯一二级索引是联合索引的话，那么所有的索引列都必须进行等值比较），则对该被驱动表的访问方法就是**eq_ref**。

   2. 举例说明：

      ```mysql
      EXPLAIN SELECT * FROM s1 INNER JOIN s2 ON s1.id = s2.id;
      ```

      ![image-20230816072020400](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230816072020400.png)

      > 从执行计划的结果中可以看出，MySQL打算将s2作为驱动表，s1作为被驱动表，s1的访问方法是 **eq_ref** ，表明在访问s1表的时候可以**通过主键的等值匹配**来进行访问。  

---

6. **ref**：

   1. 当通过普通的二级索引列与常量进行等值匹配来查询某个表，那么对该表的访问方法就可能是**ref**。

   2. 举例说明：

      ```mysql
      EXPLAIN SELECT * FROM s1 WHERE key1 = 'a';
      ```

      ![image-20230816072439063](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230816072439063.png)

      > 注意：类型相同才能使用上索引。
      >
      > ```mysql
      > EXPLAIN SELECT * FROM s1 WHERE key1 = 10066;
      > ```
      >
      > ![image-20230816073223318](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230816073223318.png)

---

7. **fulltext**：
   1. 全文索引，不常用，具体请自行百度查阅相关资料。

---

8. **ref_or_null**：

   1. 当对普通二级索引进行等值匹配查询，该索引列的值也可以是**NULL**值时，那么对该表的访问方法就可能是**ref_or_null**。

   2. 举例说明：

      ```mysql
      EXPLAIN SELECT * FROM s1 WHERE key1 = 'a' OR key1 IS NULL;
      ```

      ![image-20230816073623055](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230816073623055.png)

---

9. **index_merge**：

   1. 在某些场景下可以使用**Intersection**、**Union**、**Sort-Union**这三种索引合并的方式来执行查询，那么对该表的访问方法就是**index_merge**。

   2. 举例说明：

      ```mysql
      EXPLAIN SELECT * FROM s1 WHERE key1 = 'a' OR key3 = 'a';
      ```

      ![image-20230816074030044](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230816074030044.png)

      > 从执行计划的 type列的值是**index_merge**可以看出，MySQL打算使用**索引合并**的方式来执行对 s1 表的查询。

---

10. **unique_subquery**：

    1. 针对在一些包含**IN**子查询的查询语句中，如果查询优化器决定将**IN**子查询转换成**EXISTS**子查询，而且子查询可以使用到主键或唯一索引进行等值匹配的话，那么该子查询执行计划的**type**列的值就是**unique_subquery**。

    2. 举例说明：

       ```mysql
       EXPLAIN SELECT * FROM s1 WHERE key2 IN (SELECT id FROM s2 WHERE s1.key1 = s2.key1) OR key3 = 'a';
       ```

       ![image-20230816074726296](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230816074726296.png)

---

11. **index_subquery**：

    1. 针对在一些包含**IN**子查询的查询语句中，如果查询优化器决定将**IN**子查询转换成**EXISTS**子查询，而且子查询可以使用联合索引（非唯一索引）进行等值匹配的话，那么该子查询执行计划的**type**列的值就是**index_subquery**。

    2. 举例说明：

       ```mysql
       EXPLAIN SELECT * FROM s1 WHERE common_field IN (SELECT key3 FROM s2 where s1.key_part1 = s2.key_part1) OR key3 = 'a';
       ```

       ![image-20230816080020712](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230816080020712.png)

---

12. **range**：

    1. 如果使用索引获取某些**范围区间**的记录，那么就可能使用到**range**访问方法。

    2. 举例说明：

       ```mysql
       EXPLAIN SELECT * FROM s1 WHERE key1 IN ('a', 'b', 'c');
       # 或
       EXPLAIN SELECT * FROM s1 WHERE key1 > 'a' AND key1 < 'b';
       ```

       ![image-20230816080311866](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230816080311866.png)

---

13. **index**：

    1. 当使用索引覆盖，但需要扫描全部的索引记录时，该表的访问方法就是**index**。

    2. 举例说明：

       ```mysql
       EXPLAIN SELECT key_part2 FROM s1 WHERE key_part3 = 'a';
       ```

       ![image-20230816080443302](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230816080443302.png)

---

14. **ALL**：
    1. 全表扫描。
    2. 一般来说，这些访问方法中除了**All**这个访问方法外，其余的都能用到索引，除了index_merge之外，其余的访问方法都**最多**只能用到一个索引。

---

15. **总结：**
    1. type的结果值从最好到最坏依次是：<font color='blue'>system > const > eq_ref > ref ></font> <font color='red'>fulltext > ref_or_null > index_merge >unique_subquery > index_subquery > range > </font> <font color='green'>index > ALL </font>。
    2. SQL性能优化的目标：至少要达到**range**级别，要求是**ref**级别，最好是**const**级别。（阿里巴巴开发手册要求）。

### 6、possible_keys和key

### 7、key_len（重点）

### 8、ref

### 9、rows（重点）

### 10、filtered

### 11、Extra（重点）

### 总结

## EXPLAIN进一步使用

# 分析优化器执行计划

# 监控分析视图