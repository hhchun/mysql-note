# 优化步骤

<img src="https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/%E4%BC%98%E5%8C%96%E6%AD%A5%E9%AA%A42.svg" alt="优化步骤2" style="zoom:80%;" />

> 整个流程划分成观察（Show status）和行动（Action）两个部分。
>
> 字母 S 的部分代表观察（会使用相应的分析工具），字母 A 代表的部分是行动（对应分析可以采取的行动）。

<img src="https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/%E6%9C%80%E4%BD%8E%E7%9A%84%E6%88%90%E6%9C%AC%E8%BE%BE%E5%88%B0%E6%9C%80%E9%AB%98%E7%9A%84%E6%95%88%E6%9E%9C.svg" alt="最低的成本达到最高的效果" style="zoom:125%;" />

> 目标：最低的成本达到最高的效果。

# 查看系统性能参数

```mysql
# 查看 性能参数、执行频率
SHOW [GLOBAL|SESSION] STATUS LIKE'参数';
```

常用的性能参数：

| 参数                 | 说明                                   |
| -------------------- | -------------------------------------- |
| Connections          | 连接MySQL服务器的次数                  |
| Uptime               | MySQL服务器的上线时间                  |
| Slow_queries         | 慢查询的次数                           |
| Innodb_rows_read     | Select查询返回的行数                   |
| Innodb_rows_inserted | 执行INSERT操作插入的行数               |
| Innodb_rows_updated  | 执行UPDATE操作更新的行数               |
| Innodb_rows_deleted  | 执行DELETE操作删除的行数               |
| Com_select           | 查询操作的次数                         |
| Com_insert           | 插入操作的次数。批量插入，只累加一次。 |
| Com_update           | 更新操作的次数                         |
| Com_delete           | 删除操作的次数                         |

# 统计查询成本

一条SQL查询语句在执行前需要确定查询执行计划，如果存在多种执行计划的话，MySQL会计算每个执行计划所需要的成本，从中选择**成本最小**的一个作为最终执行的执行计划。

```mysql
# 在执行查询sql之后执行,值的单位为数据页
SHOW STATUS LIKE 'last_query_cost';
```

> 使用场景：对于比较开销是非常有用的，特别是有好几种查询方式可选的时候。
>
> 注意：查询的时间差不多一样，但查询成本可能会存在很大的差距。

# 定位慢SQL

## 开启慢查询日志

1. **开启slow_query_log。**

   ```mysql
   # 开启
   set global slow_query_log='ON';
   
   # 查看开启状态和慢查询日志文件的位置
   show variables like '%slow_query_log%';
   ```

   ![image-20230816003825607](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230816003825607.png)

2. **修改long_query_time阈值，默认为10s。**

   ```mysql
   show variables like '%long_query_time%';
   
   # 全局
   set global long_query_time = 1;
   show global variables like '%long-query_time%';
   
   # 会话
   set long_query_time=1;
   show variables like '%long_query_time%';
   ```

   > 注意：设置global的方式对当前session的long_query_time是没生效的，对新连接的客户端才有效。可以一并行上述语句。

   ![image-20230816004637823](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230816004637823.png)

3. **补充：通过配置文件设置。**

   1. 配置文件的方式相较于前面的命令行方式，可以看作是永久设置的方式。

   2. 在**my.cnf**文件**[mysqld]**下增加或修改参数**long_query_time**、**slow_query_log**和**slow_query_log_file**，保存重启MySQL服务。

      ```properties
      [mysqld]
      # 开启慢查询日志
      slow_query_log=ON 
      # 慢查询日志的目录和文件名
      slow_query_log_file=/var/lib/mysql/my-slow.log
      # 设置慢查询的阈值为3秒，超出此设定值的SQL即被记录到慢查询日志
      long_query_time=3 
      log_output=FILE
      ```

      > * 如果不指定存储路径，慢查询日志将默认存储到MySQL数据库的数据文件夹下。
      > * 如果不指定文件名，默认文件名为hostname-slow.log。

## 查看慢查询数目

开启慢SQL查询日志后，可通过以下命令查询当前系统中有多少条慢查询记录。

```mysql
SHOW GLOBAL STATUS LIKE '%Slow_queries%';
```

![image-20230816005529974](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230816005529974.png)

## 慢查询案例

1. 建表

   ```mysql
   CREATE TABLE `student` (
   `id` INT(11) NOT NULL AUTO_INCREMENT,
   `stuno` INT NOT NULL ,
   `name` VARCHAR(20) DEFAULT NULL,
   `age` INT(3) DEFAULT NULL,
   `classId` INT(11) DEFAULT NULL,
   PRIMARY KEY (`id`)
   ) ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;

2. 设置参数log_bin_trust_function_creators

   如果在创建函数时报错：This function has none of DETERMINISTIC......，可以使用命令开启创建函数设置。

   ```mysql
   # global
   set global log_bin_trust_function_creators=1;
   # session
   set log_bin_trust_function_creators=1;
   ```

3. 创建函数

   **随机产生字符串**

   ```mysql
   DELIMITER //
   CREATE FUNCTION rand_string(n INT)
   	RETURNS VARCHAR(255) #该函数会返回一个字符串
   BEGIN
       DECLARE chars_str VARCHAR(100) DEFAULT
       'abcdefghijklmnopqrstuvwxyzABCDEFJHIJKLMNOPQRSTUVWXYZ';
       DECLARE return_str VARCHAR(255) DEFAULT '';
       DECLARE i INT DEFAULT 0;
   	WHILE i < n DO
           SET return_str =CONCAT(return_str,SUBSTRING(chars_str,FLOOR(1+RAND()*52),1));
           SET i = i + 1;
   	END WHILE;
   	RETURN return_str;
   END //
   DELIMITER ;
   
   # 测试
   SELECT rand_string(10);
   ```

   ---

   **随机产生数值**

   ```mysql
   DELIMITER //
   CREATE FUNCTION rand_num (from_num INT ,to_num INT) RETURNS INT(11)
   BEGIN
   DECLARE i INT DEFAULT 0;
   SET i = FLOOR(from_num +RAND()*(to_num - from_num+1)) ;
   RETURN i;
   END //
   DELIMITER ;
   
   # 测试
   SELECT rand_num(10,100);
   ```

4. 创建存储过程

   ```mysql
   DELIMITER //
   CREATE PROCEDURE insert_stu( START INT , max_num INT )
   BEGIN
   DECLARE i INT DEFAULT 0;
       # 设置手动提交事务
       SET autocommit = 0;
       # 循环
       REPEAT 
        # 赋值
       SET i = i + 1;
       INSERT INTO student (stuno, NAME ,age ,classId ) VALUES
       ((START+i),rand_string(6),rand_num(10,100),rand_num(10,1000));
       UNTIL i = max_num
       END REPEAT;
       # 提交事务
       COMMIT;
   END //
   
   DELIMITER ;
   ```

5. 调用存储过程

   ```mysql
   CALL insert_stu(100001,4000000);
   ```

   > 4000000条记录，从100001号开始。

## 慢查询案例测试及分析

1. **测试**

   ```mysql
   SELECT * FROM student WHERE stuno = 3455655;
   ```

   ![image-20230816012439388](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230816012439388.png)

   ---

   ```mysql
   SELECT * FROM student WHERE name = 'EfLrAA';
   ```

   ![image-20230816012651448](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230816012651448.png)

   > 通过观察上诉的查询测试结果，已经达到秒的数量级，说明目前查询效率是比较低的，下面的小节分析一下原因  。

2. **分析**

   ```mysql
   # 查看慢查询数目
   show status like 'slow_queries';
   ```

   ![image-20230816012829930](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230816012829930.png)

   > **补充说明:**
   >
   > 除了上述变量，控制慢查询日志的还有一个系统变量：**min_examined_row_limit**。这个变量的意思是，查询**扫描过的最少记录数**。这个变量和查询执行时间，共同组成判断一个查询是否是慢查询的条件。如果查询扫描过的记录数大于等于这个变量的值，并且查询执行时间超过**long_query_time**的值，那么，这个查询就被记录到慢查询日志中。

## 慢查询日志分析工具：mysqldumpslow

1. 在生产环境中，如果要手工分析日志，查找、分析SQL，显然是个体力活，MySQL提供一个日志分析工具：**mysqldumpslow** 。

2. 查看mysqldumpslow的帮助信息

   ```shell
   mysqldumpslow --help
   ```

3. 命令可选参数（option）说明：

   1. -a：不将数字抽象成N，字符串抽象成S。
   2. **-s：表示按照何种方式排序**：
      - c：访问次数
      - l：锁定时间
      - r：返回记录
      - **t：查询时间**
      - al：平均锁定时间
      - ar：平均返回记录数
      - at：平均查询时间 （默认方式）
      - ac：平均查询次数
   3. **-t:：即为返回前面多少条的数据。**
   4.   **-g:：搭配一个正则匹配模式，大小写不敏感**  

4. 举例：按照查询时间排序，查看前五条**慢SQ**L语句：

   ```shell
   mysqldumpslow -a -s t -t 10 /usr/local/mysql/data/localhost-slow.log
   ```

   ![image-20230816020448241](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230816020448241.png)

5. **工作常用参考：**

   ```shell
   # 记录集最多的10个SQL
   mysqldumpslow -s r -t 10 /var/lib/mysql/atguigu-slow.log
   
   # 访问次数最多的10个SQL
   mysqldumpslow -s c -t 10 /var/lib/mysql/atguigu-slow.log
   
   # 按照时间排序的前10条里面含有左连接的查询语句
   mysqldumpslow -s t -t 10 -g "left join" /var/lib/mysql/atguigu-slow.log
   
   # 另外建议在使用这些命令时结合 | 和 more 使用，否则有可能出现爆屏情况
   mysqldumpslow -s r -t 10 /var/lib/mysql/atguigu-slow.log | more
   ```

## 关闭慢查询日志

1. **除了调优需要开，正常建议不要开启。**

2. 临时性方式关闭

   ```mysql
   SET GLOBAL slow_query_log=off;
   ```

3. **my.cnf**配置文件方式关闭

   ```properties
   [mysqld]
   # 注释掉或删除
   # slow_query_log=OFF
   ```

   > 修改配置文件后，需要重启MySQL服务。

## 删除慢查询日志

1. 查看慢查询日志文件存储的位置

   ```mysql
   show variables like '%slow_query_log%';
   ```

   ![image-20230816021356065](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230816021356065.png)

2. 从执行结果可以看出，慢查询日志的目录默认为MySQL的数据目录，在该目录下**手动删除慢查询日志文件**即可。

3. 使用命令重新生成慢查询日志文件。

   ```shell
   mysqladmin -uroot -p flush-logs slow
   ```

   > 注意：
   >
   > 1. 如果不使用命令生成，是没办法自动创建的。
   > 2. 一旦执行这个命令，慢查询日志都只存在新的日志文件中，如果需要旧的查询日志，就必须事先备份。
   > 3. 这个命令还可以重置其它日志，例如：undo日志。

# 查看慢SQL执行成本：SHOW PROFILE

1. SHOW PROFILE是MySQL提供的可以用来分析当前会话中**SQL都做了什么、执行的资源消耗情况**的工具，可用于SQL调优的分析。**默认情况下处于关闭状态**，并保存最近15次的运行结果。

2. 开启SHOW PROFILE功能

   ```mysql
   # 查看
   show variables like 'profiling';
   # 开启
   set profiling = 'ON';
   ```

   ![image-20230816022709096](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230816022709096.png)

3. 使用SHOW PROFILE命令

   ```mysql
   show profiles;
   ```

   ![image-20230816023247792](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230816023247792.png)

4. 查看最近一次查询的开销

   ```mysql
   show profile;
   ```

   <img src="https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230816023412938.png" alt="image-20230816023412938" style="zoom:70%;" />

5. 通过Query lD查看指定的开销，还可以查看不同部分的开销，比如cpu、block io等。

   ```mysql
   show profile cpu,block io for query 7;
   ```

   ![image-20230816023808019](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230816023808019.png)

6. **常用查询参数：**

   | 参数             | 描述                                                         |
   | ---------------- | ------------------------------------------------------------ |
   | ALL              | 显示所有的开销信息                                           |
   | BLOCK IO         | 显示块IO开销                                                 |
   | CONTEXT SWITCHES | 上下文切换开销                                               |
   | CPU              | 显示CPU开销信息                                              |
   | IPC              | 显示发送和接收开销信息                                       |
   | MEMORY           | 显示内存开销信息                                             |
   | PAGE FAULTS      | 显示页面错误开销信息                                         |
   | SOURCE           | 显示和Source_function，Source_file，Source_line相关的开销信息 |
   | SWAPS            | 显示交换次数开销信息                                         |

7. 日常开发需注意的结论：
   1. **converting HEAP to MyISAM**：查询结果太大，内存不够，数据往磁盘保存。
   2. **creating tmp table**：创建临时表，先拷贝数据到临时表，用完后再删除临时表。
   3. **Copying to tmp table on disk**：把内存中临时表复制到磁盘上，警惕。
   4. **locked**。
   5. 如果在show profile诊断结果中出现以上4条结果中的任何一条，则sql语句需要优化。
8. **注意**：SHOW PROFILE命令**将**被弃用，可以从information_schema中的profiling数据表进行查看。

# 分析查询：EXPLAIN

## 概述

1. **定位到查询慢的SQL之后，就可以使用EXPLAIN或DESCRIBE工具做针对性的分析查询语句。**DESCRIBE语句的使用方法与EXPLAIN语句是一样的，并且分析结果也是一样的。
2. MySQL中有专门负责优化SELECT语句的优化器模块，主要功能:：通过计算分析系统中收集到的统计信息，为客户端请求的Query提供它认为最优的**执行计划**（它认为最优的数据检索方式，但不见得是DBA认为是最优的，这部分最耗费时间)。
3. 这个执行计划展示具体执行查询的方式，比如：多表连接的顺序是什么，对于每个表采用什么访问方法来具体执行查询等等。
4. EXPLAIN的作用：查看表的读取顺序、数据读取操作的操作类型、哪些索引可以使用、**哪些索引被实际使用**、表之间的引用、**每张表有多少行被优化器查询**。
5. 官方介绍：[mysql5.7](https://dev.mysql.com/doc/refman/5.7/en/explain-output.html)、[mysql8.0](https://dev.mysql.com/doc/refman/8.0/en/explain-output.html  )。

6. **版本情况说明：**

   1. MySQL 5.6.3以前只能 EXPLAIN SELECT，MYSQL 5.6.3以后就可以 EXPLAIN SELECT / UPDATE / DELETE。

   2. 在5.7以前的版本中，想要显示**partitions**需要使用**explain partitions**命令，想要显示**filtered** 需要使用explain extended命令。在5.7版本后，默认explain直接显示partitions和filtered中的信息。  

      ![image-20230816044300027](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230816044300027.png)

## 基本语法

1. EXPLAIN 或 DESCRIBE 语句的语法形式如下：

   ```mysql
   EXPLAIN SELECT select_options
   # 或者
   DESCRIBE SELECT select_options
   ```

   举例：

   ```mysql
   EXPLAIN SELECT * FROM student LIMIT 0, 10;
   ```

   ![image-20230816044732973](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230816044732973.png)

2. EXPLAIN输出的各个列的作用：

   | 列名          | 描述                                                   |
   | ------------- | ------------------------------------------------------ |
   | id            | 在一个查询语句中每个SELECT关键字都对应一个 唯一的id    |
   | select_type   | SELECT关键字对应的那个查询的类型                       |
   | table         | 表名                                                   |
   | partitions    | 匹配的分区信息                                         |
   | **type**      | 针对单表的访问方式                                     |
   | possible_keys | 可能用到的索引                                         |
   | **key**       | **实际上使用的索引**                                   |
   | **key_len**   | **实际使用到的索引长度**                               |
   | ref           | 当使用索引列等值查询时，与索引列进行等值匹配的对象信息 |
   | **rows**      | **预估需要读取的记录数**                               |
   | filtered      | 经过过滤条件过滤后剩余记录条数的百分比                 |
   | **Extra**     | 一些额外的信息                                         |

## 数据准备

1. **建表**

   ```mysql
   CREATE TABLE s1 (
   	id INT AUTO_INCREMENT,
   	key1 VARCHAR(100), 
   	key2 INT, 
   	key3 VARCHAR(100), 
   	key_part1 VARCHAR(100),
   	key_part2 VARCHAR(100),
   	key_part3 VARCHAR(100),
   	common_field VARCHAR(100),
   	PRIMARY KEY (id),
   	INDEX idx_key1 (key1),
   	UNIQUE INDEX idx_key2 (key2),
   	INDEX idx_key3 (key3),
   	INDEX idx_key_part(key_part1, key_part2, key_part3)
   ) ENGINE=INNODB CHARSET=utf8;
   ```

   ```mysql
   CREATE TABLE s2 (
       id INT AUTO_INCREMENT,
       key1 VARCHAR(100),
       key2 INT,
       key3 VARCHAR(100),
       key_part1 VARCHAR(100),
       key_part2 VARCHAR(100),
       key_part3 VARCHAR(100),
       common_field VARCHAR(100),
       PRIMARY KEY (id),
       INDEX idx_key1 (key1),
       UNIQUE INDEX idx_key2 (key2),
       INDEX idx_key3 (key3),
   	INDEX idx_key_part(key_part1, key_part2, key_part3)
   ) ENGINE=INNODB CHARSET=utf8;
   ```

2. **设置参数 log_bin_trust_function_creators**

   如果创建函数**报错**，需开启允许创建函数设置。

   ```mysql
   # 当前session有效
   set global log_bin_trust_function_creators=1;
   ```

3.  创建函数

   ```mysql
   DELIMITER //
   # 函数功能：返回一个随机字符串
   CREATE FUNCTION rand_string1 ( n INT ) 
   	RETURNS VARCHAR (255) 
   BEGIN
   	DECLARE
   		chars_str VARCHAR (100) DEFAULT 'abcdefghijklmnopqrstuvwxyzABCDEFJHIJKLMNOPQRSTUVWXYZ';
   	DECLARE
   		return_str VARCHAR (255) DEFAULT '';
   	DECLARE
   		i INT DEFAULT 0;
   	WHILE
   			i < n DO
   			
   			SET return_str = CONCAT(
   				return_str,
   			SUBSTRING( chars_str, FLOOR( 1+RAND ()* 52 ), 1 ));
   		
   		SET i = i + 1;
   		
   	END WHILE;
   	RETURN return_str;
   	
   END // 
   DELIMITER ;
   ```

4. 创建存储过程

   ```mysql
   # 往s1表中插入数据的存储过程
   DELIMITER //
   CREATE PROCEDURE insert_s1 (IN min_num INT (10),IN max_num INT (10))
   BEGIN
       DECLARE i INT DEFAULT 0;
       SET autocommit = 0;
       REPEAT
       SET i = i + 1;
       INSERT INTO s1 VALUES(
       (min_num + i),
       rand_string1(6),
       (min_num + 30 * i + 5),
       rand_string1(6),
       rand_string1(10),
       rand_string1(5),
       rand_string1(10),
       rand_string1(10));
       UNTIL i = max_num
       END REPEAT;
       COMMIT;
   END //
   DELIMITER ;
   ```

   ```mysql
   # 往s2表中插入数据的存储过程
   DELIMITER //
   CREATE PROCEDURE insert_s2 (IN min_num INT (10),IN max_num INT (10))
   BEGIN
       DECLARE i INT DEFAULT 0;
       SET autocommit = 0;
       REPEAT
       SET i = i + 1;
       INSERT INTO s2 VALUES(
       (min_num + i),
       rand_string1(6),
       (min_num + 30 * i + 5),
       rand_string1(6),
       rand_string1(10),
       rand_string1(5),
       rand_string1(10),
       rand_string1(10));
       UNTIL i = max_num
       END REPEAT;
       COMMIT;
   END //
   DELIMITER ;
   ```

5. 调用存储过程

   ````mysql
   # 往s1表中插入1万条记录，id从10002到20001
   CALL insert_s1(10001,10000);
   ````

   ```mysql
   # 往s2表中插入1万条记录，id从10002到20001
   CALL insert_s2(10001,10000);
   ```

## EXPLAIN各列的作用

下面对EXPLAIN输出列的介绍与EXPLAIN实际输出的顺序有所调整，主要是为了方便对EXPLAIN的了解，

### 1、table

1. 不论查询语句有多复杂，包含多少个表，到最后也是需要对每个表进行 单表访问的，所以EXPLAIN语句输出的每条记录都对应着每个单表的访问方法，该条记录的table列代表着该表的表名（有时不是真实的表名字，可能是简称）。

2. 举例说明：

   ```mysql
   explain select count(*) from s1;
   ```

   ![image-20230816051429711](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230816051429711.png)

   ---

   ```mysql
   # s1：驱动表  s2：被驱动表
   EXPLAIN SELECT * FROM s1 INNER JOIN s2;
   ```

   ![image-20230816051718826](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230816051718826.png)

   > 1. 在连接查询时，驱动表和被驱动表是**优化器**决定的。
   > 2. 查询语句中用到多少张表，就会有多少条记录。

### 2、id

1. 在正常情况下，一个SELECT语句就有一个id，也有存在例外的情况，可能是查询优化器做了优化。

2. 举例说明：**正常情况**

   ```mysql
   EXPLAIN SELECT * FROM s1 WHERE key1 = 'a';
   ```

   ![image-20230816052424837](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230816052424837.png)

   ---

   ```mysql
   EXPLAIN SELECT * FROM s1 INNER JOIN s2;
   ```

   ![image-20230816052719130](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230816052719130.png)

   ---

   ```mysql
   EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2) OR key3 = 'a';
   ```

   ![image-20230816052835733](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230816052835733.png)

   > 注意：**正常情况下**子查询也是一个SELECT语句，总之就是查询语句中出现一个SELECT关键字就有一个对应的id。

3. 举例说明：**查询优化器优化**

   ```mysql
   EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key2 FROM s2 WHERE common_field = 'a');
   ```

   ![image-20230816053252948](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230816053252948.png)

   > 运行结果中，id只有一个，是因为查询优化器做了优化。

4. 举例说明：**UNION查询**

   ```mysql
   # UNION去重
   EXPLAIN SELECT * FROM s1 UNION SELECT * FROM s2;
   ```

   ![image-20230816053734303](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230816053734303.png)

   ---

   ```mysql
   # UNION ALL不去重
   EXPLAIN SELECT * FROM s1 UNION ALL SELECT * FROM s2;
   ```

   ![image-20230816053910405](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230816053910405.png)

   > UNION ALL查询不需要去重，则不需要产生临时表。

5. 总结：
   1. id值越大，优先级越高，越先执行。
   2. 如果id相同，可认为是一组，从上往下顺序执行。
   3. 结论：**每一个不同的id都表示一次独立的查询，一个SQL语句的查询次数越少越好**。

### 3、select_type

1. 在一条**大**的查询语句中可以包含**若干个**SELECT关键字，每个SELECT关键字代表着一个**小**的查询语句，而每个SELECT关键字的**FROM子句**中都可以包含**若干张表**，每一张表都对应着执行计划输出中的一条记录，对于在同一个SELECT关键字中的表来说，它们的id值是相同的。

2. MySQL为每一个SELECT关键字代表的**小查询**都定义一个称之为**select_type**的属性，意思就是只要知道某个**小查询**的**select_type**属性，就可以知道这个**小查询**在整个**大查询**中扮演着一个什么样的角色。

3. select_type有很多取值，具体如下或参考官方文档：

   | select_type Value    | JSON Name                  | Meaning                                                      |
   | :------------------- | :------------------------- | :----------------------------------------------------------- |
   | SIMPLE               | None                       | Simple SELECT(not using UNION or subqueries)                 |
   | PRIMARY              | None                       | Outermost SELECT                                             |
   | UNION                | None                       | Second or later SELECTstatement in a UNION                   |
   | DEPENDENT UNION      | dependent (true)           | Second or later SELECTstatement in a UNION, dependent on outer query |
   | UNION RESULT         | union_result               | Result of a UNION.                                           |
   | SUBQUERY             | None                       | First SELECTin subquery                                      |
   | DEPENDENT SUBQUERY   | dependent (true)           | First SELECTin subquery, dependent on outer query            |
   | DERIVED              | None                       | Derived table                                                |
   | DEPENDENT DERIVED    | dependent (true)           | Derived table dependent on another table                     |
   | MATERIALIZED         | materialized_from_subquery | Materialized subquery                                        |
   | UNCACHEABLE SUBQUERY | cacheable (false)          | A subquery for which the result cannot be cached and must be re-evaluated for each row of the outer query |
   | UNCACHEABLE UNION    | cacheable (false)          | The second or later select in a UNION that belongs to an uncacheable subquery (see UNCACHEABLE SUBQUERY) |

---

4. **SIMPLE**：

   1. 查询语句中不包含**UNION**或者**子查询**的查询都算作是SIMPLE类型。

      ```mysql
      EXPLAIN SELECT * FROM s1;
      ```

   2. 连接查询也算是SIMPLE类型。

      ```mysql
      EXPLAIN SELECT * FROM s1 INNER JOIN s2;
      ```

---

5. **PRIMARY、UNION、UNION RESULT**：

   1. MySQL选择使用临时表来完成**UNION查询**的去重工作，针对该临时表的查询的**select_type**就是**UNION RESULT**。

   2. 对于包含UNION、UNION ALL或子查询的**大查询**来说，它是由几个**小查询**组成的，其中最左边的那个小查询的**select_type**值是**PRIMARY**，其余的小查询是**UNION**。

   3. 举例说明：

      ```mysql
      EXPLAIN SELECT * FROM s1 UNION SELECT * FROM s2;	
      ```

      ![image-20230816061630827](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230816061630827.png)

      ---

      ```mysql
      EXPLAIN SELECT * FROM s1 UNION ALL SELECT * FROM s2;
      ```

      ![image-20230816061718344](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230816061718344.png)

----

6. **SUBQUERY：**

   1. 如果包含子查询的查询语句不能够转为对应的**semi-join**的形式，并且该子查询是**不相关子查询**，并且查询优化器决定采用将该子查询**物化**的方案来执行该子查询时，则该子查询的**第一个**SELECT关键字对应的那个查询的**select_type**就是 **SUBQUERY**。

   2. 举例说明：

      ```mysql
      EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2) OR key3 = 'a';
      ```

      ![image-20230816062246530](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230816062246530.png)

----

7. **DEPENDENT SUBQUERY：**

   1. 如果包含子查询的查询语句不能够转为对应的**semi-join**的形式，并且该子查询是**相关子查询**，则该子查询的第一个SELECT关键字代表的那个查询的**select_type**就是**DEPENDENT SUBQUERY**。

   2. 举例说明：

      ```mysql
      EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2 WHERE s1.key2 = s2.key2) OR key3 = 'a';
      ```

      ![image-20230816062816721](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230816062816721.png)

---

8. **DEPENDENT UNION：**

   1. 在包含UNION或者UNION ALL的**大查询**中，如果各个小查询都依赖于外层查询的话，除了**最左边**的那个**小查询**之外，其余的小查询的**select_type**值就是**DEPENDENT UNION**。

   2. 举例说明：

      ```mysql
      EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2 WHERE key1 = 'a' UNION SELECT key1 FROM s1 WHERE key1 = 'b');
      ```

      ![image-20230816063646707](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230816063646707.png)

---

9. **DERIVED**：

   1. 对于包含**派生表**的查询，该**派生表**对应的**子查询**的**select_type**值就是**DERIVED**。

   2. 举例说明：

      ```mysql
      EXPLAIN SELECT * FROM (SELECT key1, COUNT(*) AS c FROM s1 GROUP BY key1) AS derived_s1 WHERE c > 1;
      ```

      ![image-20230816064027853](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230816064027853.png)

---

10. **MATERIALIZED**：

    1. 当查询优化器在执行包含子查询的语句时，选择将子查询**物化**之后与外层查询进行连接查询时，该子查询对应的**select_type**值就是**MATERIALIZED**。

    2. 举例说明：

       ```mysql
       EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2);
       ```

       ![image-20230816064416476](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230816064416476.png)

---

11. **UNCACHEABLE SUBQUERY、UNCACHEABLE UNION**：不常用，这里不做说明。

### 4、partitions（可忽略）

1. 在分区表中才有意义，如果想了解，可以创建分区表来进行测试：

   ```mysql
   CREATE TABLE user_partitions (
       id INT auto_increment,
       NAME VARCHAR(12),PRIMARY KEY(id))
       PARTITION BY RANGE(id)(
       PARTITION p0 VALUES less than(100),
       PARTITION p1 VALUES less than MAXVALUE
   );
   ```

   > 说明：按照id进行分区，id小于100在p0分区，其余的都是在p1分区。

2. 测试查询：

   ```mysql
   EXPLAIN SELECT * FROM user_partitions WHERE id<100;
   
   EXPLAIN SELECT * FROM user_partitions WHERE id>=100;
   ```

   ![image-20230816065811705](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230816065811705.png)

### 5、type（重点）

1. 执行计划的一条记录就代表着MySQL对某个表的**执行查询时的访问方法**，又称"访问类型”，其中的**type**列用于说明这个访问方法是啥，是较为**重要**的一个指标。
2. 完整的访问方法： **system、const、eq_ref、ref、fulltext、ref_or_null、index_merge、unique_subquery、 index_subquery、range、 index、ALL **。

---

3. **system**：

   1. 当表中**只有一条记录**并且该表使用的存储引擎的统计数据是精确的，比如MyISAM、Memory，那么对该表的访问方法就是**system**。

   2. 举例说明：新建一个**MyISAM**表，并为其插入一条记录。

      ```mysql
      # 建表
      CREATE TABLE t(i int) Engine=MyISAM;
      
      # 插入一条记录
      INSERT INTO t VALUES(1);
      ```

      ```mysql
      EXPLAIN SELECT * FROM t;
      ```

      ![image-20230816071208358](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230816071208358.png)

      > 注意：如果是 innoDB 会变成ALL ， 因为innoDB不会存记录数量，而MyISAM会存储。

---

4. **const**：

   1. 根据主键或者唯一二级索引列与**常数**进行等值匹配时，访问方法就是**const**。

   2. 举例说明：

      ```mysql
      EXPLAIN SELECT * FROM s1 WHERE id = 10005;
      
      EXPLAIN SELECT * FROM s1 WHERE key2 = '10066';
      ```

      ![image-20230816071731719](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230816071731719.png)

---

5. **eq_ref**：

   1. 在连接查询时，如果被驱动表是通过主键或者唯一二级索引列等值匹配的方式进行访问的（如果该主键或者唯一二级索引是联合索引的话，那么所有的索引列都必须进行等值比较），则对该被驱动表的访问方法就是**eq_ref**。

   2. 举例说明：

      ```mysql
      EXPLAIN SELECT * FROM s1 INNER JOIN s2 ON s1.id = s2.id;
      ```

      ![image-20230816072020400](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230816072020400.png)

      > 从执行计划的结果中可以看出，MySQL打算将s2作为驱动表，s1作为被驱动表，s1的访问方法是 **eq_ref** ，表明在访问s1表的时候可以**通过主键的等值匹配**来进行访问。  

---

6. **ref**：

   1. 当通过普通的二级索引列与常量进行等值匹配来查询某个表，那么对该表的访问方法就可能是**ref**。

   2. 举例说明：

      ```mysql
      EXPLAIN SELECT * FROM s1 WHERE key1 = 'a';
      ```

      ![image-20230816072439063](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230816072439063.png)

      > 注意：类型相同才能使用上索引。
      >
      > ```mysql
      > EXPLAIN SELECT * FROM s1 WHERE key1 = 10066;
      > ```
      >
      > ![image-20230816073223318](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230816073223318.png)

---

7. **fulltext**：
   1. 全文索引，不常用，具体请自行百度查阅相关资料。

---

8. **ref_or_null**：

   1. 当对普通二级索引进行等值匹配查询，该索引列的值也可以是**NULL**值时，那么对该表的访问方法就可能是**ref_or_null**。

   2. 举例说明：

      ```mysql
      EXPLAIN SELECT * FROM s1 WHERE key1 = 'a' OR key1 IS NULL;
      ```

      ![image-20230816073623055](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230816073623055.png)

---

9. **index_merge**：

   1. 在某些场景下可以使用**Intersection**、**Union**、**Sort-Union**这三种索引合并的方式来执行查询，那么对该表的访问方法就是**index_merge**。

   2. 举例说明：

      ```mysql
      EXPLAIN SELECT * FROM s1 WHERE key1 = 'a' OR key3 = 'a';
      ```

      ![image-20230816074030044](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230816074030044.png)

      > 从执行计划的 type列的值是**index_merge**可以看出，MySQL打算使用**索引合并**的方式来执行对 s1 表的查询。

---

10. **unique_subquery**：

    1. 针对在一些包含**IN**子查询的查询语句中，如果查询优化器决定将**IN**子查询转换成**EXISTS**子查询，而且子查询可以使用到主键或唯一索引进行等值匹配的话，那么该子查询执行计划的**type**列的值就是**unique_subquery**。

    2. 举例说明：

       ```mysql
       EXPLAIN SELECT * FROM s1 WHERE key2 IN (SELECT id FROM s2 WHERE s1.key1 = s2.key1) OR key3 = 'a';
       ```

       ![image-20230816074726296](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230816074726296.png)

---

11. **index_subquery**：

    1. 针对在一些包含**IN**子查询的查询语句中，如果查询优化器决定将**IN**子查询转换成**EXISTS**子查询，而且子查询可以使用联合索引（非唯一索引）进行等值匹配的话，那么该子查询执行计划的**type**列的值就是**index_subquery**。

    2. 举例说明：

       ```mysql
       EXPLAIN SELECT * FROM s1 WHERE common_field IN (SELECT key3 FROM s2 where s1.key_part1 = s2.key_part1) OR key3 = 'a';
       ```

       ![image-20230816080020712](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230816080020712.png)

---

12. **range**：

    1. 如果使用索引获取某些**范围区间**的记录，那么就可能使用到**range**访问方法。

    2. 举例说明：

       ```mysql
       EXPLAIN SELECT * FROM s1 WHERE key1 IN ('a', 'b', 'c');
       # 或
       EXPLAIN SELECT * FROM s1 WHERE key1 > 'a' AND key1 < 'b';
       ```

       ![image-20230816080311866](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230816080311866.png)

---

13. **index**：

    1. 当使用索引覆盖，但需要扫描全部的索引记录时，该表的访问方法就是**index**。

    2. 举例说明：

       ```mysql
       EXPLAIN SELECT key_part2 FROM s1 WHERE key_part3 = 'a';
       ```

       ![image-20230816080443302](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230816080443302.png)

---

14. **ALL**：
    1. 全表扫描。
    2. 一般来说，这些访问方法中除了**All**这个访问方法外，其余的都能用到索引，除了index_merge之外，其余的访问方法都**最多**只能用到一个索引。

---

15. **总结：**
    1. type的结果值从最好到最坏依次是：<font color='blue'>system > const > eq_ref > ref ></font> <font color='red'>fulltext > ref_or_null > index_merge >unique_subquery > index_subquery > range > </font> <font color='green'>index > ALL </font>。
    2. SQL性能优化的目标：至少要达到**range**级别，要求是**ref**级别，最好是**const**级别。（阿里巴巴开发手册要求）。

### 6、possible_keys和key

1.  **possible_keys**列表示在某个查询语句中，对某个表执行**查询时可能用到的索引**有哪些，一般查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询使用。

2. **key**列表示**实际用到的索引**有哪些，如果为NULL，则没有使用索引。

3. 举例说明：

   ```mysql
   EXPLAIN SELECT * FROM s1 WHERE key1 > 'z' AND key3 = 'a';
   ```

   ![image-20230817014036067](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230817014036067.png)

   > * **possible_keys**列的值是：**idx_key1,idx_key3**，表示该查询可能使用到**idx_key1**和**idx_key3**两个索引。
   > * **key**列的值是：**idx_key3**，表示经过查询优化器计算使用不同索引的成本后，最后决定使用**idx_key3**。

### 7、key_len（重点）

1. key_len表示**实际使用到的索引长度**，即字节数。

2. 一般情况key_len的值越小索引效果越好，但在**联合索引**里，命中次数越多长度越长，精度越高效果越好。

3. 举例说明：

   ```mysql
   EXPLAIN SELECT * FROM s1 WHERE id = 10005;
   ```

   ![image-20230817015532344](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230817015532344.png)

   > PRIMARY是主键索引id，类型为int，不允许为null值，占4个字节。

   ---

   ```mysql
   EXPLAIN SELECT * FROM s1 WHERE key2 = 10126;
   ```

   ![image-20230817015848552](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230817015848552.png)

   > idx_key2索引包含key2字段，类型是int占4个字节，允许为null值占1个字节，共占用5个字节。

   ---

   ```mysql
   EXPLAIN SELECT * FROM s1 WHERE key1 = 'a';
   ```

   ![image-20230817020632426](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230817020632426.png)

   > idx_key1索引包含key1字段，类型为varchar(100)，每个字符占3个字节，允许为null值占1个字节，varchar为变长类型占2个字节，所以长度为：3 * 100 + 1 + 2 = 303 个字节。
   
   ---
   
   ```mysql
   EXPLAIN SELECT * FROM s1 WHERE key_part1 = 'a';
   ```
   
   ![image-20230817021645893](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230817021645893.png)
   
   > idx_key_part索引包含key_part1、key_part2和key_part3字段，实际使用到key_part1字段，key_part1字段类型为varchar(100)，每个字符占3个字节，允许为null值占1个字节，varchar为变长类型占2个字节，所以长度为：3 * 100 + 1 + 2 = 303 个字节。
   
   ---
   
   ```mysql
   EXPLAIN SELECT * FROM s1 WHERE key_part1 = 'a' AND key_part2 = 'b';
   ```
   
   ![image-20230817021949975](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230817021949975.png)
   
   > idx_key_part索引包含key_part1、key_part2和key_part3字段，实际使用到key_part1、key_part2字段，类型都是varchar(100)，每个字符占3个字节，允许为null值占1个字节，varchar为变长类型占2个字节，所以长度为：(3 * 100 + 1 + 2) + (3 * 100 + 1 + 2) = 606 个字节。
   >
   > **Tips：这里命中两次联合索引（idx_key_part），精度越高，效果越好。**

4. **key_len的长度计算公式：**
   1. varchar(10)变长字段且允许NULL = 10 * ( character set：utf8=3，gbk=2，latin1=1) + 1(NULL) + 2(变长字段)。
   2. varchar(10)变长字段且不允许NULL = 10 * ( character set：utf8=3，gbk=2，latin1=1) + 2(变长字段)。
   3. char(10)固定字段且允许NULL = 10 * ( character set：utf8=3，gbk=2，latin1=1) + 1(NULL)。
   4. char(10)固定字段且不允许NULL = 10 * ( character set：utf8=3，gbk=2，latin1=1)。

### 8、ref

1. 当使用索引列等值查询时，与索引列进行等值匹配的对象信息，比如：一个常数或者是某个列。

2. 举例说明：

   ```mysql
   EXPLAIN SELECT * FROM s1 WHERE key1 = 'a';
   ```

   ![image-20230817023259853](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230817023259853.png)

   > type = ref，与const（常量）比较。

   ---

   ```mysql
   EXPLAIN SELECT * FROM s1 INNER JOIN s2 ON s1.id = s2.id;
   ```

   ![image-20230817023429779](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230817023429779.png)

   > type = eq_ref，与s1.id列比较。

   ---

   ```mysql
   EXPLAIN SELECT * FROM s1 INNER JOIN s2 ON s2.key1 = UPPER(s1.key1);
   ```

   ![image-20230817023616034](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230817023616034.png)

### 9、rows（重点）

1. 预估的需要读取的记录条数，值越小效果越好，通常与[filtered](#10、filtered)一起使用。
2. rows值越小，代表数据越有可能在一个页里，这样IO就会更小。

### 10、filtered

1. filtered的值指返回结果的行占需要读到的行([rows](#9、rows（重点）)的值)的百分比。

2. **对于单表查询来说，filtered列的值是没什么意义的**，主要关注的是**连接查询中驱动表对应的执行计划记录的filtered值**，它决定被驱动表要执行的次数，即rows * filtered。

   ![image-20230817025144102](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230817025144102.png)

   > 9895 * 10% = 989

### 11、Extra（重点）

1. 用来说明一些额外信息的，包含不适合在其他列中显示但十分重要的额外信息。
2. 可以通过这些额外信息来**更准确的理解MySQL到底将如何执行给定的查询语句**。
3. MySQL提供的额外信息有很多，下面针对常见的进行重点介绍。

---

4. **No tables used**：当查询语句的没有FROM子句时将会提示该额外信息。

   ```mysql
   EXPLAIN SELECT 1;
   ```

   ![image-20230817025637635](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230817025637635.png)

---

5. **Impossible WHERE**：查询语句的**WHERE**子句永远为**FALSE**时将会提示该额外信息。

   ```mysql
   EXPLAIN SELECT * FROM s1 WHERE 1 != 1;
   ```

   ![image-20230817025759269](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230817025759269.png)

---

6. **Using where**：

   1. 当使用**全表扫描**来执行某个表的查询，并且该语句的WHERE子句中有对该表的过滤条件时，则会提示该额外信息。

      ```mysql
      EXPLAIN SELECT * FROM s1 WHERE common_field = 'a';
      ```

      ![image-20230817030147014](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230817030147014.png)

   2. 当**使用索引**来执行某个表的查询，并且该语句的WHERE子句中除了该索引包含的列之外的其他过滤条件时，则会提示该额外信息。

      ```mysql
      EXPLAIN SELECT * FROM s1 WHERE key1 = 'fUhcQU' and  common_field = 'uDHCOnalcF';
      ```

      ![image-20230817031317980](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230817031317980.png)

---

7. **No matching min/max row**：当查询列表中有**MIN**或**MAX**聚合函数，但并没有符合WHERE子句中的过滤条件的记录时，则会提示该额外信息。

   ```mysql
   EXPLAIN SELECT MIN(key1) FROM s1 WHERE key1 = 'QLjKYOx';
   ```

   ![image-20230817031649664](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230817031649664.png)

---

8. **Using index**：当查询列表以及过滤条件中只包含属于某个索引的列，也就是在可以使用覆盖索引，不需要回表的情况下，则会提示该额外信息。

   ```mysql
   EXPLAIN SELECT key1 FROM s1 WHERE key1 = 'a';
   ```

   ![image-20230817032134737](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230817032134737.png)

---

9. **Using index condition**：在有些查询的过滤条件中虽然出现索引列，但却不能都使用到索引，也称为**索引条件下推（Index Condition Pushdown）**，则会提示该额外信息。

   ```mysql
   EXPLAIN SELECT * FROM s1 WHERE key_part1 > 'z' AND key_part2 LIKE '%a';
   ```

   ![image-20230817040750718](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230817040750718.png)

   **索引条件下推说明：**

   * 上述的查询中**key_part1 > 'z'**可以使用到索引，但是**key_part2 LIKE '%a '**却无法使用到索引。

   * 在以前版本的MySQL中，执行上述的查询步骤:
     1. 先根据**key_part1 > 'z'**条件，从二级索引**idx_key_part**中获取到对应的**索引记录**。
     2. 根据**索引记录**中的主键值进行回表，找到完整的用户记录再比较该记录是否符合**key_part2 LIKE '%a'**这个条件，将符合条件的记录加入到最后的结果集。
   * 虽然**key_part1 LIKE ‘%a'**不能组成范围区间参与**range**访问方法的执行，但这个条件毕竟涉及到**idx_key_part**索引的**key_part2**列，所以MySQL把上边的步骤改进一下：
     1. 先根据**key_part1 > 'z'**条件，定位到二级索引**idx_key_part**中对应的**索引记录**。
     2. 对于指定的索引记录，先不着急回表，而是先比较该记录是否满足**key_part2 LIKE ‘%a'**条件，如果条件不满足，则该索引记录压根就没必要回表，如果条件满足，该索引记录根据主键值进行回表操作。
   * 回表操作其实是**随机I/O**，比较耗时，所以上述修改虽然只改进了一点点，但是可以省去好多回表操作的成本。
   * MySQL把这个改进称之为**索引条件下推（Index Condition Pushdown）**。如果在查询语句的执行过程中将要使用**索引条件下推**，在**Extra**列中将会提示**Using index condition**。

---

10. **Using join buffer (Block Nested Loop)**：在连接查询执行过程中，当被驱动表不能有效的利用索引加快访问速度，MySQL一般会为其分配一块名叫**join buffer**的内存块来加快查询速度，也就是所谓的**基于块的嵌套循环算法**。

    ```mysql
    EXPLAIN SELECT * FROM s1 INNER JOIN s2 ON s1.common_field = s2.common_field;
    ```

    ![image-20230817041319471](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230817041319471.png)

---

11. **Not exists**：当使用左外连接时，如果**WHERE子句**中包含被驱动表的某个列等于**NULL**值的过滤条件，而且这个列又是不允许存储**NULL**值的，那么在该表**Extra**列就会提示**Not exists**。

    ```mysql
    EXPLAIN SELECT * FROM s1 LEFT JOIN s2 ON s1.key1 = s2.key1 WHERE s2.id IS NULL;
    ```

    ![image-20230817041713298](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230817041713298.png)

---

12. **Using intersect(...) 、 Using union(...) 和 Using sort_union(...)**

    **索引合并**，当同一个表中的搜索条件中同时存在多个索引的时候，MySQL会分别对这些索引进行扫描，然后将扫描结果进行合并，合并分三种情况：

    1. **Using intersect(...)** ：对多个扫描结果求**交集**（AND），触发**Using intersect**，需要满足以下条件：

       1. 如果是二级索引，则必须是**等值**查询，如果二级索引是**联合索引**，则**联合索引**的**每一列**都必须覆盖到，不能只是覆盖到部分列。
       2. **主键索引**可以是**范围**查询。

       ```mysql
       EXPLAIN SELECT * FROM s1 WHERE id < 500 AND key_part1 = 'a' AND key_part2 = 'a' AND key_part3 = 'a';
       ```

    2. **Using union(...)**：对多个扫描结果求**并集**（OR），与**Using intersect**较像，就是把AND变成OR。

       1. 如果是二级索引，则必须是**等值**查询，如果二级索引是**联合索引**，则**联合索引**的**每一列**都必须覆盖到，不能只是覆盖到部分列。
       2. **主键索引**可以是**范围**查询。

       ```mysql
       EXPLAIN SELECT * FROM s1 WHERE key1 = 'a' OR (key_part1 = 'a' AND key_part2 = 'a' AND key_part3 = 'a')
       ```

       ![image-20230817055409904](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230817055409904.png)

    3. **Using sort_union(...)**：先对多个扫描结果的**主键值进行排序**，然后才去求并集或交集。

       1. 需要满足**Using union**的条件比较苛刻，二级索引必须是**等值**查询才能触发**Using union**，在很多使用情况下，范围查询也是非常常见的，所以就有了**Using sort_union**。

       ```mysql
       EXPLAIN SELECT * FROM s1 WHERE key2 < 24196 OR s1.key3 < 'a';
       ```

       ![image-20230817060814902](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230817060814902.png)

----

13. **Zero limit**：

    ```mysql
    EXPLAIN SELECT * FROM s1 LIMIT 0;
    ```

    ![image-20230817061004512](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230817061004512.png)

----

14. **Using filesort**：

    1. 很多情况下排序操作无法使用到索引，只能在内存中或磁盘中进行排序，MySQL把这种在内存中或磁盘上进行排序的方式统称为**文件排序（filesort)**。
    2. 如果某个查询需要使用**文件排序**的方式执行查询，就会在**Extra**列中提示**Using filesort**。

    ```mysql
    EXPLAIN SELECT * FROM s1 WHERE key2 < 49966 ORDER BY common_field LIMIT 10;
    ```

    ![image-20230817061729148](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230817061729148.png)

---

15. **Using temporary**：

    1. 在许多查询的执行过程中，MySQL可能会借助**临时表**来完成一些功能，比如去重、排序之类的。比如在执行许多包含**DISTINCT**、**GROUP BY**、**UNION**等子句的查询过程中，如果不能有效利用索引来完成查询，MySQL很有可能通过建立内部的**临时表**来执行查询。
    2. 如果使用到内部的临时表，就会在**Extra**列中提示**Using temporary**，它的出现并不是一个好的征兆，，因为建立与维护临时表要付出很大的性能成本，所以**最好使用索引来替代掉使用临时表**。
    
    ```mysql
    EXPLAIN SELECT DISTINCT common_field FROM s1;
    ```
    
    ![image-20230817062151141](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230817062151141.png)

## 补充说明

1. EXPLAIN只是部分统计信息是估算的，并非精确值。
2. EXPLAIN不能显示MySQL在执行查询时所作的优化工作，不能显示关于触发器、存储过程的信息或用户自定义函数对查询的影响情况。

## EXPLAIN进一步使用

### EXPLAIN四种输出格式

#### 传统格式

传统格式简单明了，输出的是一个表格形式，概要说明查询计划。

```mysql
EXPLAIN SELECT s1.key1, s2.key1 FROM s1 LEFT JOIN s2 ON s1.key1 = s2.key1 WHERE
s2.common_field IS NOT NULL; 
```

![image-20230817063628514](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230817063628514.png)

#### JSON格式

1. **传统格式**中介绍的**EXPLAIN**输出中缺少一个衡量执行计划好坏的重要属性：成本。而JSON格式是四种格式里面输出信息**最详尽的**，里面包含执行的成本信息。

   ```mysql
   EXPLAIN FORMAT=JSON SELECT * FROM s1 INNER JOIN s2 ON s1.key1 = s2.key2 WHERE s1.common_field = 'a' \G
   ```

2. EXPLAIN的Column与JSON的对应关系：

   | Column        | JSON Name     | Meaning                                        |
   | ------------- | ------------- | ---------------------------------------------- |
   | id            | select id     | The SELECT identifier                          |
   | select_type   | None          | The SELECT type                                |
   | table         | table_name    | The table for the output row                   |
   | partitions    | partitions    | The matching partitions                        |
   | **type**      | access_type   | The join type                                  |
   | possible_keys | possible_keys | The possible indexes to choose                 |
   | **key**       | key           | The index actually chosen                      |
   | **key_len**   | key_length    | The length of the chosen key                   |
   | ref           | ref           | The columns compared to the index              |
   | **rows**      | rows          | Estimate of rows to be examined                |
   | filtered      | filtered      | Percentage of rows filtered by table condition |
   | **Extra**     | None          | Additional information                         |

3. 举例说明

   ```mysql
   EXPLAIN FORMAT=JSON SELECT * FROM s1 INNER JOIN s2 ON s1.key1 = s2.key2 WHERE s1.common_field = 'a' \G
   ```

   ```json
   {
     "query_block": {
       "select_id": 1,
       "cost_info": {
         "query_cost": "3263.40"
       },
       "nested_loop": [
         {
           "table": {
             "table_name": "s1",
             "access_type": "ALL",
             "possible_keys": [
               "idx_key1"
             ],
             "rows_examined_per_scan": 9895,
             "rows_produced_per_join": 989,
             "filtered": "10.00",
             "cost_info": {
               "read_cost": "1878.10",
               "eval_cost": "197.90",
               "prefix_cost": "2076.00",
               "data_read_per_join": "1M"
             },
             "used_columns": [
               "id",
               "key1",
               "key2",
               "key3",
               "key_part1",
               "key_part2",
               "key_part3",
               "common_field"
             ],
             "attached_condition": "((`mysql_demo`.`s1`.`common_field` = 'a') and (`mysql_demo`.`s1`.`key1` is not null))"
           }
         },
         {
           "table": {
             "table_name": "s2",
             "access_type": "ref",
             "possible_keys": [
               "idx_key2"
             ],
             "key": "idx_key2",
             "used_key_parts": [
               "key2"
             ],
             "key_length": "5",
             "ref": [
               "mysql_demo.s1.key1"
             ],
             "rows_examined_per_scan": 1,
             "rows_produced_per_join": 989,
             "filtered": "100.00",
             "index_condition": "(`mysql_demo`.`s1`.`key1` = `mysql_demo`.`s2`.`key2`)",
             "cost_info": {
               "read_cost": "989.50",
               "eval_cost": "197.90",
               "prefix_cost": "3263.40",
               "data_read_per_join": "1M"
             },
             "used_columns": [
               "id",
               "key1",
               "key2",
               "key3",
               "key_part1",
               "key_part2",
               "key_part3",
               "common_field"
             ]
           }
         }
       ]
     }
   }
   ```

   存在的**疑问**：**cost_info**里的各个成本是怎么计算出来的？

   1. 先来看s1表的**cost_info**：

      ```json
      "cost_info": {
        "read_cost": "1878.10",
        "eval_cost": "197.90",
        "prefix_cost": "2076.00",
        "data_read_per_join": "1M"
      }
      ```

      * **read_cost**：由IO成本和检测**rows × (1 - filter)** 条记录的CPU成本。在JSON格式中，rows相当于rows_examined_per_scan，filtered名称不变。
      * **eval_cost**：检测**rows × (1 - filter)** 条记录的CPU成本。
      * **prefix_cost**：单独查询 **s1** 表的成本，就是**read_cost + eval_cost**。
      * **data_read_per_join**：表示在此次查询中需要读取的数据量。

   2. 接下来看s2表的**cost_info**：

      ```json
      "cost_info": {
        "read_cost": "989.50",
        "eval_cost": "197.90",
        "prefix_cost": "3263.40",
        "data_read_per_join": "1M"
      }
      ```

      由于 **s2**表是被驱动表，所以可能被读取多次，这里的**read_cost**和 **eval_cost**是访问多次**s2**表后累加的值，主要关注 **prefix_cost**的值代表的是整个连接查询预计的成本，也就是**单次查询 s1表**和**多次查询 s2 表**的成本和，就是：

      ```tex
      989.50 + 197.90 + 2076.00 = 3263.4
      ```

#### TREE格式

TREE格式是**8.0.16版本之后**引入的新格式，主要根据查询的**各个部分之间的关系**和**各部分的执行顺序**来描述如何查询。

```mysql
EXPLAIN FORMAT=tree SELECT * FROM s1 INNER JOIN s2 ON s1.key1 = s2.key2 WHERE s1.common_field = 'a'\G
```

```mysql
*************************** 1. row ***************************
EXPLAIN: -> Nested loop inner join  (cost=1360.08 rows=990)
    -> Filter: ((s1.common_field = 'a') and (s1.key1 is not null))  (cost=1013.75 rows=990)
        -> Table scan on s1  (cost=1013.75 rows=9895)
    -> Single-row index lookup on s2 using idx_key2 (key2=s1.key1), with index condition: (cast(s1.key1 as double) = cast(s2.key2 as double))  (cost=0.25 rows=1)

1 row in set, 1 warning (0.00 sec)
```

#### 可视化输出

可视化输出，可以通过MySQL Workbench可视化查看MySQL的执行计划。

```mysql
SELECT * FROM s1 INNER JOIN s2 ON s1.key1 = s2.key2 WHERE s1.common_field = 'a';
```

![image-20230817071424956](https://hhc-typora.oss-cn-shenzhen.aliyuncs.com/image-20230817071424956.png)

#### SHOW WARNINGS的使用

使用完**EXPLAIN**后紧接着使用**SHOW WARNINGS**，可以获取到查询优化器真正执行的语句（复制出来并不一定可以执行）。

```mysql
EXPLAIN SELECT s1.key1, s2.key1 FROM s1 LEFT JOIN s2 ON s1.key1 = s2.key1 WHERE s2.common_field IS NOT NULL;
# 后执行
SHOW WARNINGS\G
```

```mysql
*************************** 1. row ***************************
  Level: Note
   Code: 1003
Message: /* select#1 */ select `mysql_demo`.`s1`.`key1` AS `key1`,`mysql_demo`.`s2`.`key1` AS `key1` from `mysql_demo`.`s1` join `mysql_demo`.`s2` where ((`mysql_demo`.`s1`.`key1` = `mysql_demo`.`s2`.`key1`) and (`mysql_demo`.`s2`.`common_field` is not null))
1 row in set (0.00 sec)
```

1. 可以看到展示出来的信息有三个字段，分别是**Level、Code、Message**。
2. 最常见的就是**Code**为1003的信息，当Code值为1003时，**Message**展示的信息类似于查询优化器**重写后的语句**。
3. 比如上边的查询本来是一个左外连接查询，但有一个**s2.common_field IS NOT NULL**的条件，就会导致查询优化器把**左外连接**查询优化为**内连接**查询，从**Message**字段就可以看出来，原本的**LEFT JOIN**变成**JOIN**。

# 分析优化器执行计划：trace

1. **OPTIMIZER_TRACE**是MySQL 5.6引入的一项跟踪功能，它可以跟踪优化器做出的各种决策，比如：访问表的方法、各种开销计算、各种转换等，并将跟踪结果记录到INFORMATION_SCHEMA.OPTIMIZER_TRACE表中。

2. 此功能默认关闭。开启trace，并设置格式为JSON，同时设置trace最大能够使用的内存大小，避免解析过程中因为默认内存过小而不能够完整展示。

   ```mysql
   SET optimizer_trace="enabled=on",end_markers_in_json=on;
   
   set optimizer_trace_max_mem_size=1000000;
   ```

3. 开启后，可分析的语句：SELECT、INSERT、REPLACE、UPDATE、DELETE、EXPLAIN、SET、DECLARE、CASE、IF、RETURN、CALL。

4. 举例说明：

   ```mysql
   # 执行sql
   select * from student where id < 10;
   ```

   ```mysql
   # 查询information_schema.optimizer_trace表
   select * from information_schema.optimizer_trace\G;
   ```

   ```json
   TRACE: {
     "steps": [
       {
         "join_preparation": { /* 预备工作 */
           "select#": 1,
           "steps": [
             {
               "expanded_query": "/* select#1 */ select `student`.`id` AS `id`,`student`.`stuno` AS `stuno`,`student`.`name` AS `name`,`student`.`age` AS `age`,`student`.`classId` AS `classId` from `student` where (`student`.`id` < 10)"
             }
           ] /* steps */
         } /* join_preparation */
       },
       {
         "join_optimization": { /* 进行优化 */
           "select#": 1,
           "steps": [
             {
               "condition_processing": { /* 条件处理 */
                 "condition": "WHERE",
                 "original_condition": "(`student`.`id` < 10)",
                 "steps": [
                   {
                     "transformation": "equality_propagation",
                     "resulting_condition": "(`student`.`id` < 10)"
                   },
                   {
                     "transformation": "constant_propagation",
                     "resulting_condition": "(`student`.`id` < 10)"
                   },
                   {
                     "transformation": "trivial_condition_removal",
                     "resulting_condition": "(`student`.`id` < 10)"
                   }
                 ] /* steps */
               } /* condition_processing */
             },
             {
               "substitute_generated_columns": { /* 替换生成的列 */
               } /* substitute_generated_columns */
             },
             {
               "table_dependencies": [ /* 表的依赖关系 */
                 {
                   "table": "`student`",
                   "row_may_be_null": false,
                   "map_bit": 0,
                   "depends_on_map_bits": [
                   ] /* depends_on_map_bits */
                 }
               ] /* table_dependencies */
             },
             {
               "ref_optimizer_key_uses": [ /* 使用的键 */
               ] /* ref_optimizer_key_uses */
             },
             {
               "rows_estimation": [
                 {
                   "table": "`student`",
                   "range_analysis": { 
                     "table_scan": { /* 表扫描 */
                       "rows": 13553763,
                       "cost": 2.75e6
                     } /* table_scan */,
                     "potential_range_indexes": [
                       {
                         "index": "PRIMARY",
                         "usable": true,
                         "key_parts": [
                           "id"
                         ] /* key_parts */
                       }
                     ] /* potential_range_indexes */,
                     "setup_range_conditions": [
                     ] /* setup_range_conditions */,
                     "group_index_range": { /* 设置条件范围 */
                       "chosen": false,
                       "cause": "not_group_by_or_distinct"
                     } /* group_index_range */,
                     "analyzing_range_alternatives": { /* 分析范围选项 */
                       "range_scan_alternatives": [
                         {
                           "index": "PRIMARY",
                           "ranges": [
                             "id < 10"
                           ] /* ranges */,
                           "index_dives_for_eq_ranges": true,
                           "rowid_ordered": true,
                           "using_mrr": false,
                           "index_only": false,
                           "rows": 9,
                           "cost": 2.8199,
                           "chosen": true
                         }
                       ] /* range_scan_alternatives */,
                       "analyzing_roworder_intersect": {
                         "usable": false,
                         "cause": "too_few_roworder_scans"
                       } /* analyzing_roworder_intersect */
                     } /* analyzing_range_alternatives */,
                     "chosen_range_access_summary": { /* 选择范围访问摘要 */
                       "range_access_plan": {
                         "type": "range_scan",
                         "index": "PRIMARY",
                         "rows": 9,
                         "ranges": [
                           "id < 10"
                         ] /* ranges */
                       } /* range_access_plan */,
                       "rows_for_plan": 9,
                       "cost_for_plan": 2.8199,
                       "chosen": true
                     } /* chosen_range_access_summary */
                   } /* range_analysis */
                 }
               ] /* rows_estimation */
             },
             {
               "considered_execution_plans": [  /* 考虑执行计划 */
                 {
                   "plan_prefix": [
                   ] /* plan_prefix */,
                   "table": "`student`",
                   "best_access_path": {
                     "considered_access_paths": [ /* 最佳访问路径 */
                       {
                         "rows_to_scan": 9,
                         "access_type": "range",
                         "range_details": {
                           "used_index": "PRIMARY"
                         } /* range_details */,
                         "resulting_rows": 9,
                         "cost": 4.6199,
                         "chosen": true
                       }
                     ] /* considered_access_paths */
                   } /* best_access_path */,
                   "condition_filtering_pct": 100, /* 行过滤百分比 */
                   "rows_for_plan": 9,
                   "cost_for_plan": 4.6199,
                   "chosen": true
                 }
               ] /* considered_execution_plans */
             },
             {
               "attaching_conditions_to_tables": { /* 将条件附加到表上 */
                 "original_condition": "(`student`.`id` < 10)",
                 "attached_conditions_computation": [
                 ] /* attached_conditions_computation */,
                 "attached_conditions_summary": [ /* 附加条件概要 */
                   {
                     "table": "`student`",
                     "attached": "(`student`.`id` < 10)"
                   }
                 ] /* attached_conditions_summary */
               } /* attaching_conditions_to_tables */
             },
             {
               "refine_plan": [ /* 精简计划 */
                 {
                   "table": "`student`"
                 }
               ] /* refine_plan */
             }
           ] /* steps */
         } /* join_optimization */
       },
       {
         "join_execution": { /* 执行 */
           "select#": 1,
           "steps": [
           ] /* steps */
         } /* join_execution */
       }
     ] /* steps */
   }
   /* 第3部分：跟踪信息过长时，被截断的跟踪信息的字节数。*/
   MISSING_BYTES_BEYOND_MAX_MEM_SIZE: 0 /* 丢失的超出最大容量的字节 */
   /* 第4部分：执行跟踪语句的用户是否有查看对象的权限。当不具有权限时，该列信息为1且TRACE字段为空，
   					一般在调用带有SQL SECURITY DEFINER的视图或者是存储过程的情况下，会出现此问题。*/
             INSUFFICIENT_PRIVILEGES: 0 /* 缺失权限 */
   1 row in set (0.00 sec)
   ```

# 监控分析视图：sys schema

## Sys schema视图摘要

1. **主机相关**：以host_summary开头，主要汇总了IO延迟的信息。
2. **Innodb相关**：以innodb开头，汇总了innodb buffer信息和事务等待innodb锁的信息。
3. **I/o相关**：以io开头，汇总了等待I/O、I/O使用量情况。
4. **内存使用情况**：以memory开头，从主机、线程、事件等角度展示内存的使用情况
5. **连接与会话信息**：processlist和session相关视图，总结了会话相关信息。
6. **表相关**：以schema_table开头的视图，展示了表的统计信息。
7. **索引信息**：统计了索引的使用情况，包含冗余索引和未使用的索引情况。
8. **语句相关**：以statement开头，包含执行全表扫描、使用临时表、排序等的语句信息。
9. **用户相关**：以user开头的视图，统计了用户使用的文件I/O、执行语句统计信息。
10. **等待事件相关信息**：以wait开头，展示等待事件的延迟情况。

## Sys schema视图使用场景

### 索引相关

1. 查询冗余索引

   ```mysql
   select * from sys.schema_redundant_indexes;
   ```

2. 查询未使用过的索引

   ```mysql
   select * from sys.schema_unused_indexes;
   ```

3. 查询索引的使用情况

   ```mysql
   select index_name,rows_selected,rows_inserted,rows_updated,rows_deleted
   from sys.schema_index_statistics where table_schema='数据库名';
   ```

### 表相关

1. 查询表的访问量

   ```mysql
   select table_schema,table_name,sum(io_read_requests+io_write_requests) as io from
   sys.schema_table_statistics group by table_schema,table_name order by io desc;
   ```

2. 查询占用bufferpool较多的表

   ```mysql
   select object_schema,object_name,allocated,data
   from sys.innodb_buffer_stats_by_table order by allocated limit 10;
   ```

3. 查看表的全表扫描情况

   ```mysql
   select * from sys.statements_with_full_table_scans where db='数据库名';
   ```

### 语句相关

1. 监控SQL执行的频率

   ```mysql
   select db,exec_count,query from sys.statement_analysis order by exec_count desc;
   ```

2. 监控使用了排序的SQL

   ```mysql
   select db,exec_count,first_seen,last_seen,query from sys.statements_with_sorting limit 1;
   ```

3. 监控使用临时表或者磁盘临时表的SQL

   ```mysql
   select db,exec_count,tmp_tables,tmp_disk_tables,query from sys.statement_analysis where tmp_tables>0 or tmp_disk_tables >0 order by (tmp_tables+tmp_disk_tables) desc;
   ```

### IO相关

1. 查看消耗磁盘IO的文件

   ```mysql
   select file,avg_read,avg_write,avg_read+avg_write as avg_io from sys.io_global_by_file_by_bytes order by avg_read limit 10;
   ```

### Innodb 相关

1. 行锁阻塞情况

   ```mysql
   select * from sys.innodb_lock_waits;
   ```

### 风险提示

通过sys库去查询时，MySQL会消耗大量资源去收集相关信息，严重的可能会导致业务请求被阻塞，从而引起故障。建议生产上**不要频繁**的去查询sys或者performance_schema、information_schema来完成监控、巡检等工作。